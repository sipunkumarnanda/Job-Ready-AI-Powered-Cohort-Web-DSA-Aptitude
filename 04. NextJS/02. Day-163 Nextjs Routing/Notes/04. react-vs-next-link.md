
# React `<Link to="…">` vs Next.js `<Link href="…">` 

**TL;DR:**
`to` (React Router) and `href` (Next.js) both tell the browser *where* to go when a user clicks a link — but they come from different routing models and therefore behave differently. React Router’s `to` targets **routes declared in your app’s router table** and supports pushing *history state*. Next.js’s `href` targets **URLs (usually produced by the filesystem routing)** and is tightly integrated with Next’s server/client rendering and automatic prefetching. Below is a thorough, from-A-to-Z comparison with examples and practical advice.

---

## 1) High-level difference (why `to` vs `href` exist)

* **React Router (`to`)**

  * React Router is a client-side routing library. You *declare* routes in code with `<Routes>` / `<Route path=... element=.../>`. `<Link to="...">` points to one of those route paths (or a location object). Routing & matching happen in the client memory (SPA style).
* **Next.js (`href`)**

  * Next.js uses file/folder-based routing (`pages/` or `app/`), server rendering, and hybrid SSR/SSG strategies. `<Link href="...">` is primarily a *URL* navigation helper that integrates with Next’s server/client lifecycle (preloading, SSR/SSG, and App Router server components).

Because the routing model is different, the prop names reflect intent:

* `to` → "go to this *route* in my client router".
* `href` → "go to this *URL* (resource)"; in Next.js the URL usually maps to a file/folder page.

---

## 2) What the props accept (types & shapes)

### React Router (`to`)

```jsx
// string form
<Link to="/courses/cohort1">Cohort 1</Link>

// location object form (v6)
<Link to={{
  pathname: "/login",
  search: "?redirect=/private",
  hash: "#section",
  state: { from: "/private" }
}}>
  Login
</Link>
```

* `to` can be a string or a location-like object.
* The object can include `state` — a convenient client-only history state that is **not** visible in the URL.

### Next.js (`href`)

```jsx
// string form
import Link from 'next/link';
<Link href="/courses/cohort1">Cohort 1</Link>

// object form (commonly used for dynamic routes)
<Link href={{
  pathname: '/courses/[cohort]',
  query: { cohort: 'cohort1' }
}}>
  Cohort 1
</Link>
```

* `href` can be a string or an object with `pathname` + `query`.
* **No built-in `state` field** (i.e., you cannot attach arbitrary transient history state the same way you do with React Router). Use query params or client-side state (context, store, sessionStorage) instead.

---

## 3) Under the hood: what happens on click

Both `Link` components:

* Render an anchor-like element and intercept clicks to avoid a full browser reload.
* Use the History API (`pushState`/`replaceState`) to change the URL without a hard refresh when client-side navigation is possible.

Differences:

* **React Router**: navigation triggers the client router to match the new route and render the associated component(s) from the in-memory route table (fast, entirely client-side after initial load).
* **Next.js**: navigation triggers Next’s router which may:

  * If running client-side and the target page JS has already been downloaded (or prefetch is complete), render client-side (fast).
  * If not loaded, fetch the page chunk (and optionally data) from the server and then render client-side.
  * If navigation needs server-rendered HTML (first load or fallback), server response may be used. Next’s Link also coordinates with SSG/SSR semantics (cache/ISR, etc.).

---

## 4) Prefetching & performance

* **React Router:** no automatic prefetching. You can implement code-splitting with `React.lazy` and manually prefetch route chunks (e.g., `import()` on hover), but that’s up to you.
* **Next.js:** Next’s `<Link>` *automatically prefetches* the JavaScript (and some data under the App Router) for internal links that are visible in the viewport (in production). That makes the first client-side navigation nearly instant because the page code is already fetched.

*Practical effect:* With React Router you often lazy-load and manually prefetch; with Next.js, prefetching is built into the framework so navigation tends to feel faster by default.

---

## 5) Server-side rendering, SEO, and crawling

* **React Router**: by default is client-side — crawlers may see little HTML unless you set up SSR (which requires extra configuration e.g., frameworks like Remix or manual SSR).
* **Next.js**: built with SSR/SSG in mind — pages are server-rendered or statically generated, making links crawlable and good for SEO. `<Link href="...">` preserves normal anchor semantics so crawlers and crawlers/robots can follow links.

---

## 6) Passing transient data between pages

* **React Router**: use `state` in the `to` object. The `state` is kept in the history entry (not visible in the URL). Example:

  ```jsx
  <Link to="/checkout" state={{ fromCart: true }}>Checkout</Link>

  // In Checkout component
  const location = useLocation();
  console.log(location.state.fromCart);
  ```
* **Next.js**: no `state` prop. Alternatives:

  * Use query string (`/checkout?fromCart=1`) for small pieces of info.
  * Use client-side state (Context, Redux, Zustand).
  * Use cookies/localStorage/sessionStorage for cross-page persistence.
  * Use server-side session or backend to pass info via server-rendered data.

---

## 7) Programmatic navigation (APIs)

* **React Router**

  ```jsx
  import { useNavigate } from 'react-router-dom';
  const navigate = useNavigate();
  navigate('/login');            // push
  navigate('/dashboard', { replace: true }); // replace
  ```
* **Next.js**

  * **Pages Router** (older): `import { useRouter } from 'next/router'`
  * **App Router**: `import { useRouter } from 'next/navigation'` (client components)

  ```jsx
  const router = useRouter();
  router.push('/courses/cohort1');    // push
  router.replace('/login');           // replace
  ```

Note: In Next.js App Router you must run router hooks inside **client components** (`'use client'`) — server components cannot call client hooks.

---

## 8) Nested routes / layouts (how links relate to structure)

* **React Router:** nested routes are declared with `<Route>` nesting and rendered with `<Outlet />` where child routes appear. Links point to nested paths (`to="cohort1"` or `to="/courses/cohort1"`).
* **Next.js:** nested routing is **folder-based**. A `courses/layout.js` provides shared UI for `courses/*` and child pages live in `courses/cohort1/page.js`. Links refer to the corresponding URL (`/courses/cohort1`). There’s no explicit `<Route>` table to keep in sync — the filesystem is the source of truth.

---

## 9) Active link styling

* **React Router:** has `<NavLink>` with built-in `isActive` helpers to set classNames/styles automatically.

  ```jsx
  <NavLink to="/courses" className={({isActive}) => isActive ? 'active' : ''}>Courses</NavLink>
  ```
* **Next.js:** `<Link>` does not provide active-state logic. Use `usePathname()` (App Router) or `useRouter().pathname` (Pages Router) and compare the current path to `href` to set classes.

---

## 10) Accessibility & anchor semantics

* Both render HTML anchors (so right-click, open-in-new-tab, middle click, SEO crawlers, and screen readers behave correctly).
* Historically Next.js required putting an `<a>` inside `<Link>`; modern Next.js renders an `<a>` by default (the `legacyBehavior` flag preserves old behavior). React Router’s `<Link>` renders an anchor by default as well.
* Always ensure `rel`/`target` usage is correct for external links (`rel="noopener noreferrer"`, `target="_blank"`).

---

## 11) Practical side-by-side examples

### React Router (v6) — nested route + state

```jsx
// App.jsx
<Routes>
  <Route path="/courses" element={<CoursesLayout />}>
    <Route index element={<CoursesIndex />} />
    <Route path=":cohort" element={<Cohort />} />
  </Route>
</Routes>

// Some nav component
<Link to="/courses/cohort1" state={{ invited: true }}>Cohort 1</Link>

// Cohort component can read:
const location = useLocation();
console.log(location.state?.invited); // true
```

### Next.js (App Router) — folder-based nested route

```
app/
  courses/
    layout.js           // shared nav/layout
    page.js             // /courses
    [cohort]/
      page.js           // /courses/:cohort
```

```jsx
// app/courses/page.js
import Link from 'next/link';
export default function Courses() {
  return <Link href="/courses/cohort1">Cohort 1</Link>;
}

// To pass data: use query or context, e.g.
<Link href={{ pathname: '/courses/[cohort]', query: { invited: '1', cohort: 'cohort1' } }}>
  Cohort 1
</Link>
```

---

## 12) Common pitfalls & gotchas

* **Expecting `state` in Next.js:** React Router lets you attach transient `state`. Next.js does not — many developers try to mirror the pattern and get surprised. Use query/Context/localStorage instead.
* **Relying on prefetch in development:** Next.js prefetch behavior is optimized for production — don’t rely on it being identical in dev.
* **Using `<Link>` for external links:** Both frameworks allow anchors; prefer plain `<a>` for external destinations to avoid framework-specific behaviors.
* **Confusing route declarations:** In React Router you must keep `<Route>` definitions in sync with `to` values; in Next.js the filesystem controls routes — don’t try to declare them both places.
* **Client vs server hooks (Next.js App Router):** `useRouter()` / `usePathname()` must be used only in client components. If you try to use them in server components you’ll get errors.

---

## 13) Best practices & recommendations

* Use **React Router** when you want full control over in-app route declarations (e.g., an SPA inside a non-Next environment), and you want easy `state` passing in history entries.
* Use **Next.js** when you want file-based routing, SSR/SSG/ISR, built-in prefetching, and SEO-first pages. For transient per-navigation data, use query params or client-side state rather than history state.
* **Always provide semantic anchors** (for accessibility). Prefer framework `<Link>` for internal navigation and `<a>` for external links.
* For active styles in Next.js, centralize path checks (a tiny utility that normalizes pathnames helps).
* Avoid leaking sensitive data in query params — use server-side sessions or encrypted tokens if needed.

---

## 14) Quick FAQ (mini)

**Q: Can Next.js Link attach `state` like React Router?**
A: No. Next.js `href` supports pathname + query. Use URL query or client/global state instead.

**Q: Which is faster on click?**
A: Next.js often feels faster because of automatic prefetching (production). React Router can be equally fast if you implement prefetching & code-splitting.

**Q: Do both work with nested routes?**
A: Yes — React Router via `<Route>` nesting + `<Outlet />`; Next.js via nested folders + `layout.js` (App Router) or nested files (Pages Router).

---

## 15) Final example — complete small comparison (courses → cohort)

**React Router**

```jsx
// Nav.jsx
<Link to="/courses">Courses</Link>
<Link to="/courses/cohort1">Cohort 1</Link>

// Routes
<Routes>
  <Route path="/courses" element={<CoursesLayout />}>
    <Route index element={<CoursesIndex />} />
    <Route path="cohort1" element={<Cohort1 />} />
  </Route>
</Routes>
```

**Next.js (app/)**

```
app/
  layout.js
  courses/
    layout.js
    page.js                // /courses
    cohort1/
      page.js              // /courses/cohort1
```

```jsx
// app/courses/page.js
import Link from 'next/link';

export default function Page() {
  return (
    <ul>
      <li><Link href="/courses/cohort1">Cohort 1</Link></li>
    </ul>
  );
}
```

---

## Wrap-up

`to` and `href` look similar at first glance — both point to “where” — but they reflect two distinct routing philosophies:

* **React Router** = explicit in-app route declarations + richer client-side navigation state (the `state` object).
* **Next.js** = URL-driven, filesystem-mapped routes + framework-level integrations (SSR/SSG, prefetching, server components), where `href` is the canonical way to reference those URLs.