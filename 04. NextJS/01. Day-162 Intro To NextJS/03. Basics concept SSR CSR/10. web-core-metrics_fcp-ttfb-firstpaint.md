
# Quick TL;DR ✨

* **TTFB (Time To First Byte)** — how long until the *first* byte of the server response arrives (network + server latency). 🕒. ([web.dev][1])
* **FP (First Paint)** — the very first time the browser paints *any* pixels that differ from the default background (may be just a background color). 🎨. ([MDN Web Docs][2])
* **FCP (First Contentful Paint)** — when the browser renders the **first bit of actual content** from the DOM (text, image, SVG, non-blank canvas). This is a strong user-visible signal: “something happened.” ✅. ([web.dev][3], [MDN Web Docs][2])

---

# 1) TTFB — Time To First Byte (deep dive) ⏱️

**What it is**
TTFB measures the time between the browser issuing a request and the first byte of the response arriving. It includes DNS lookup, TCP/TLS handshake, network latency, and server processing time before the server begins sending bytes. ([web.dev][1], [MDN Web Docs][4])

**Why it matters**
TTFB is *fundamental* because it precedes every paint — a slow TTFB delays FP, FCP, LCP and everything that follows. If the server doesn’t start streaming HTML quickly, the browser has nothing to parse/render. ([web.dev][5])

**How it’s measured (programmatically)**
Use the Navigation Timing / PerformanceNavigationTiming API:

```js
const [nav] = performance.getEntriesByType('navigation');
if (nav) {
  // requestStart -> when request was sent, responseStart -> first byte received
  const ttfb = nav.responseStart - nav.requestStart;
  console.log('TTFB (ms):', Math.round(ttfb));
}
```

Older `performance.timing` properties are deprecated — prefer `getEntriesByType('navigation')`. ([MDN Web Docs][4])

**Good/Bad numbers (guidance)**
Google’s guidance (via web.dev) suggests treating TTFB ≲ **0.8s** as *good* and > **1.8s** as *poor* — aim lower when you can because smaller TTFB helps all downstream metrics. (Teams sometimes target very aggressive server response times like <200 ms for static pages, but real-world dynamic pages have other constraints.) ([web.dev][1], [Kinsta®][6])

**How to improve TTFB (high level)**

* Put responses on a **CDN / edge** (cache HTML or use edge rendering).
* Cache more aggressively (page, object, DB query results).
* Optimize server code & DB queries; avoid blocking operations.
* Keep connections warm (Keep-Alive), HTTP/2 or HTTP/3, and TLS session reuse.
* Use preconnect / DNS prefetch for critical third-party endpoints. ([web.dev][5])

---

# 2) First Paint (FP) — what it is & gotchas 🎨

**Definition**
FP is the first time the browser paints pixels that are visually different from the default background (e.g., background color, or tiny UI element). Not every user agent reports FP; browsers vary in what they expose. It’s less useful than FCP for user-feedback because the first paint could be an innocuous background. ([MDN Web Docs][2])

**How to read it**
You can read paint entries from the Performance API:

```js
const paints = performance.getEntriesByType('paint'); // may include 'first-paint'
console.log(paints);
```

But: **FP is optional** in some UAs — prefer FCP for user-centric measurements. ([MDN Web Docs][2])

---

# 3) First Contentful Paint (FCP) — deep dive ✅

**What FCP measures**
FCP is the timestamp when the browser renders the **first bit of DOM content** (text, image, SVG, non-white canvas). It answers the user question: *“Is something appearing?”* — so it’s an important perceived-speed metric. ([web.dev][3], [MDN Web Docs][7])

**How browsers expose it**
Use the Paint Timing entries (PerformancePaintTiming) or `PerformanceObserver`:

```js
if ('PerformanceObserver' in window) {
  const po = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      if (entry.name === 'first-contentful-paint') {
        console.log('FCP (ms):', Math.round(entry.startTime));
        // e.g. send with navigator.sendBeacon('/r', JSON.stringify({metric:'fcp', value:entry.startTime}));
      }
    }
  });
  po.observe({ type: 'paint', buffered: true });
}
```

This is the modern, recommended approach; the `buffered: true` option picks up the entry even if it already happened. ([Adobe Open Source][8], [Medium][9])

**Why it matters & scoring**

* FCP is used in lab tools (Lighthouse) and RUM to indicate the first visible feedback to users.
* Google/web.dev considers **FCP ≤ 1.8 s** (75th percentile on mobile/desktop) as *good*, **1.8–3.0 s** as *needs improvement*, and **> 3.0 s** as *poor*. Aim to get FCP under \~1.8s for most users. ([web.dev][3])

**What influences FCP**

* **TTFB** (if HTML arrives late, paints are delayed).
* **Render-blocking CSS and synchronous JS** that block parser/stylesheet application.
* **Web fonts** (blocking layout/paint if poorly configured).
* **Large critical resources** (images, heavy CSS).
* **Third-party scripts** that block the main thread or resource loading. ([web.dev][3])

**How to improve FCP (practical)**

* Reduce **TTFB** (see previous section).
* Critical CSS: *inline* critical-path CSS or use `rel="preload"` for key CSS.
* Defer or async non-critical JS; minimize blocking scripts in `<head>`.
* Use `font-display: swap` and preload critical webfonts (or avoid blocking fonts).
* Prioritize and preload hero images/icons that appear above the fold.
* Server-side render (SSR) or deliver at least meaningful HTML shell early. ([web.dev][3])

---

# 4) How FP, FCP, and TTFB fit together 🔗

* **TTFB** happens earliest: it determines when the browser *starts* receiving response bytes. If TTFB is high, FP/FCP are necessarily delayed. ([web.dev][1])
* **FP** may be the browser painting a background or tiny element.
* **FCP** is the first *meaningful* content paint (text/image) — usually what we target to improve perceived speed. ([MDN Web Docs][2], [web.dev][3])

Think of it as a chain:
`navigation → (network + server) TTFB → parsing HTML → apply CSS → FP/FCP → LCP → Time to Interactive (TTI) / INP`

---

# 5) Lab vs Field & Tools 🔧

* **Field (real users)**: Chrome User Experience Report (CrUX), RUM with `PerformanceObserver` + sendBeacon, or web analytics with web-vitals library. Field data shows real networks/devices. ([Google for Developers][10])
* **Lab**: Lighthouse (DevTools), PageSpeed Insights (lab + CrUX), WebPageTest — reproducible, great for debugging but simulated network/device. ([Chrome for Developers][11], [DebugBear][12])

**Pro tip:** measure both — use lab tests to find bottlenecks and RUM to verify fixes in production.

---

# 6) Quick actionable checklist ✅ (copy-paste)

* Measure FCP & TTFB with `PerformanceObserver` (send to analytics). ([Adobe Open Source][8])
* Reduce TTFB: caching, CDN/edge, optimize server + DB. ([web.dev][5])
* Remove render-blocking CSS/JS; inline critical CSS. ([web.dev][3])
* Preload key resources (fonts, hero images), use `font-display: swap`. ([web.dev][3])
* Defer non-critical JS and trim third-party scripts.
* Validate in field (CrUX / RUM) and lab (Lighthouse / WebPageTest).

---

# Quick examples (ready to paste) 🧩

**Measure FCP and send to analytics:**

```js
if ('PerformanceObserver' in window) {
  const po = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
      if (entry.name === 'first-contentful-paint') {
        navigator.sendBeacon('/collect-metrics', JSON.stringify({
          metric: 'fcp',
          value: Math.round(entry.startTime)
        }));
      }
    }
  });
  po.observe({ type: 'paint', buffered: true });
}
```

**Measure TTFB:**

```js
const [nav] = performance.getEntriesByType('navigation');
const ttfb = nav ? (nav.responseStart - nav.requestStart) : null;
console.log('TTFB ms:', ttfb ? Math.round(ttfb) : 'n/a');
```

(Use `getEntriesByType('navigation')` for accurate PerformanceNavigationTiming data.) ([MDN Web Docs][4], [Adobe Open Source][8])

---