
## âœ… Problem: Leetcode 50 â€“ Pow(x, n) using Recursion

### ğŸ“Œ Goal:
Compute \( x^n \) using recursion in an optimized way.

---

## ğŸ§  Key Concept: Exponentiation by Squaring (Recursive)

Instead of multiplying `x` by itself `n` times (which takes `O(n)` time), we use **divide and conquer**:

- If `n == 0`: return 1
- If `n % 2 == 0`:  
  \( x^n = (x^{n/2})^2 \)
- If `n % 2 != 0`:  
  \( x^n = (x^{\lfloor n/2 \rfloor})^2 \times x \)

âœ… This reduces the **time complexity to O(log n)**

---

## ğŸ” Code:
```js
function pow(x, n) {
    if (n == 0) return 1.00;

    let ans = pow(x, Math.floor(n / 2));  // ğŸŸ¡ Recursive call (waits for result)

    if (n % 2 == 0) {
        return ans * ans;  // ğŸ” Executes only after ans returns
    } else {
        return ans * ans * x;  // ğŸ” Executes only after ans returns
    }
}

console.log(pow(2, 10));  // Output: 1024
```

---

## ğŸªœ Step-by-Step Recursion & Execution (for x = 2, n = 10)

### Let's Trace pow(2, 10):

| Call               | n Value | Waits for...        |
|--------------------|---------|----------------------|
| `pow(2, 10)`        | 10      | â†’ `pow(2, 5)`         |
| `pow(2, 5)`         | 5       | â†’ `pow(2, 2)`         |
| `pow(2, 2)`         | 2       | â†’ `pow(2, 1)`         |
| `pow(2, 1)`         | 1       | â†’ `pow(2, 0)`         |
| `pow(2, 0)`         | 0       | âœ… returns 1          |

Now unwinding:

1. `pow(2, 0)` â†’ **returns** 1
2. `pow(2, 1)`:
   - `ans = 1`
   - Since 1 is odd â†’ `return 1 * 1 * 2 = 2`
3. `pow(2, 2)`:
   - `ans = 2`
   - Even â†’ `return 2 * 2 = 4`
4. `pow(2, 5)`:
   - `ans = 4`
   - Odd â†’ `return 4 * 4 * 2 = 32`
5. `pow(2, 10)`:
   - `ans = 32`
   - Even â†’ `return 32 * 32 = 1024 âœ…`

---

## ğŸ“Š Call Stack Visualization (Top to Bottom = Most Recent to Oldest)

Before Returning:
```
pow(2, 10)
 â””â”€ pow(2, 5)
     â””â”€ pow(2, 2)
         â””â”€ pow(2, 1)
             â””â”€ pow(2, 0)
```

After Returning:
```
pow(2, 0) â†’ returns 1
pow(2, 1) â†’ returns 2
pow(2, 2) â†’ returns 4
pow(2, 5) â†’ returns 32
pow(2, 10) â†’ returns 1024
```

Each call **waits** at:
```js
let ans = pow(x, Math.floor(n / 2));
```
until it **receives a value** from the recursive call. **Only then** the `if...else` block below it executes.

---

![image](./Assets/Math_Pow(x,n).jpg)
## ğŸ§® Time & Space Complexity:

| Type             | Complexity     |
|------------------|----------------|
| Time Complexity  | **O(log n)**   |
| Space Complexity | **O(log n)** (due to call stack depth)

---

## âœ… Advantages:

- Much faster than `O(n)` loop-based approach
- Clean recursive structure
- Efficient for large `n`

---


---
---




#-----------------------------



```js
pow(2, 10)
```

---

## ğŸ” Recursive Function Code Again (for reference):
```js
function pow(x, n) {
    if (n == 0) return 1.00;

    let ans = pow(x, Math.floor(n / 2));  // â¸ Pauses here until the result comes

    if (n % 2 == 0) {
        return ans * ans;
    } else {
        return ans * ans * x;
    }
}
```

---

### âœ… Step-by-Step Execution:

---

### ğŸ”¹ Step 1: `pow(2, 10)`
- `n = 10` â‰  0, so not the base case
- Executes:
  ```js
  let ans = pow(2, 5); // Waits here
  ```

---

### ğŸ”¹ Step 2: `pow(2, 5)`
- `n = 5`, odd, so:
  ```js
  let ans = pow(2, 2); // Waits here
  ```

---

### ğŸ”¹ Step 3: `pow(2, 2)`
- `n = 2`, even:
  ```js
  let ans = pow(2, 1); // Waits here
  ```

---

### ğŸ”¹ Step 4: `pow(2, 1)`
- `n = 1`, odd:
  ```js
  let ans = pow(2, 0); // Waits here
  ```

---

### ğŸ”¹ Step 5: `pow(2, 0)` âœ… **Base Case**
- `n == 0` so:
  ```js
  return 1;
  ```
  ğŸ“¤ Returned to `pow(2, 1)`

---

## ğŸ§  Now we start returning back:

---

### ğŸ” Back to `pow(2, 1)`:
```js
let ans = 1;          // Returned from pow(2, 0)
return 1 * 1 * 2;     // Since n = 1 is odd â†’ returns 2
```

ğŸ“¤ Returned to `pow(2, 2)`

---

### ğŸ” Back to `pow(2, 2)`:
```js
let ans = 2;          // Returned from pow(2, 1)
return 2 * 2 = 4;     // Since n = 2 is even
```

ğŸ“¤ Returned to `pow(2, 5)`

---

### ğŸ” Back to `pow(2, 5)`:
```js
let ans = 4;            // Returned from pow(2, 2)
return 4 * 4 * 2 = 32;  // Since n = 5 is odd
```

ğŸ“¤ Returned to `pow(2, 10)`

---

### ğŸ” Final: `pow(2, 10)`:
```js
let ans = 32;            // Returned from pow(2, 5)
return 32 * 32 = 1024;   // Since n = 10 is even
```

âœ… Final Output:
```
1024
```

---

## ğŸ“Š Final Summary Table:

| Call           | Returned From | ans value | Even/Odd | Return Calculation      | Return Value |
|----------------|---------------|-----------|----------|--------------------------|--------------|
| `pow(2, 0)`    | â€”             | â€”         | base     | return 1                 | 1            |
| `pow(2, 1)`    | `pow(2, 0)`   | 1         | Odd      | 1 * 1 * 2                | 2            |
| `pow(2, 2)`    | `pow(2, 1)`   | 2         | Even     | 2 * 2                    | 4            |
| `pow(2, 5)`    | `pow(2, 2)`   | 4         | Odd      | 4 * 4 * 2                | 32           |
| `pow(2, 10)`   | `pow(2, 5)`   | 32        | Even     | 32 * 32                  | 1024         |

---

## ğŸªœ Final Call Stack (bottom-up unwind):

```
pow(2, 10) â†’ pow(2, 5)
pow(2, 5)  â†’ pow(2, 2)
pow(2, 2)  â†’ pow(2, 1)
pow(2, 1)  â†’ pow(2, 0)
pow(2, 0)  â†’ 1 (base case)
```

Each call **waits at this line**:
```js
let ans = pow(x, Math.floor(n / 2));
```
...until the **recursive call returns**. Then only the `if...else` block below it executes.

---