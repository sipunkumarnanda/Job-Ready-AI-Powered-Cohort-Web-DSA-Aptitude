
## âœ… Function Code
```js
function pow(x, n) {
  if (n === 0) return 1.0;

  return n < 0 ? 1 / temp(x, n) : temp(x, n);
}

function temp(x, n) {
  if (n == 0) return 1;

  let ans = temp(x, Math.floor(n / 2));

  if (n % 2 == 0) {
    return ans * ans;
  } else {
    return ans * ans * x;
  }
}

console.log(pow(2, 10)); // âž¤ Output: 1024
```

---

## ðŸ” Overview

- The `pow(x, n)` function calculates `x` raised to the power `n` using **efficient recursion**.
- If `n` is negative, we compute `1 / x^|n|`.
- The helper function `temp(x, n)` uses **exponentiation by squaring**.
- It minimizes recursive depth and number of multiplications.

---

## ðŸ” Function Call: `pow(2, 10)`

### ðŸ‘‰ Step 1:
```js
n = 10 is not 0 or negative â†’ call temp(2, 10)
```

---

## ðŸ“Œ Let's Now Expand: `temp(2, 10)`

Each call will **pause at**:
```js
let ans = temp(x, Math.floor(n / 2));
```
...until it gets a return value.

---

### ðŸ”½ Recursion Tree & Return Flow

1. `temp(2, 10)`
   - âž¤ calls `temp(2, 5)`
2. `temp(2, 5)`
   - âž¤ calls `temp(2, 2)`
3. `temp(2, 2)`
   - âž¤ calls `temp(2, 1)`
4. `temp(2, 1)`
   - âž¤ calls `temp(2, 0)`
5. `temp(2, 0)`
   - âž¤ Base case â†’ returns `1`

---

## ðŸ” Now Unwinding the Stack (returns):

### ðŸ”™ Return to `temp(2, 1)`
- `ans = 1`
- `n = 1` is odd â†’ return `1 * 1 * 2 = 2`

---

### ðŸ”™ Return to `temp(2, 2)`
- `ans = 2`
- `n = 2` is even â†’ return `2 * 2 = 4`

---

### ðŸ”™ Return to `temp(2, 5)`
- `ans = 4`
- `n = 5` is odd â†’ return `4 * 4 * 2 = 32`

---

### ðŸ”™ Return to `temp(2, 10)`
- `ans = 32`
- `n = 10` is even â†’ return `32 * 32 = 1024`

---

## âœ… Final Output:
```
console.log(pow(2, 10)); // 1024
```

---

## ðŸ“Š Summary Table

| Call           | Returns From      | ans Value | Even/Odd | Return Formula         | Return Value |
|----------------|-------------------|-----------|----------|-------------------------|--------------|
| `temp(2, 0)`    | â€”                 | â€”         | Base     | return 1                | 1            |
| `temp(2, 1)`    | `temp(2, 0)`      | 1         | Odd      | 1 * 1 * 2               | 2            |
| `temp(2, 2)`    | `temp(2, 1)`      | 2         | Even     | 2 * 2                   | 4            |
| `temp(2, 5)`    | `temp(2, 2)`      | 4         | Odd      | 4 * 4 * 2               | 32           |
| `temp(2, 10)`   | `temp(2, 5)`      | 32        | Even     | 32 * 32                 | 1024         |

---

## ðŸ“š Concept Used: **Exponentiation by Squaring (Recursive)**
- **Reduces time complexity to** `O(log n)`
- Works for both **positive and negative exponents**
- Uses:
  - Divide `n` by 2 each time
  - Square results
  - Multiply by `x` if `n` is odd

---

## ðŸ§  Key Takeaways

- Every recursive call **waits at `let ans = temp(...)`** until it receives a return.
- After receiving it, it calculates `ans * ans` or `ans * ans * x` based on even/odd.
- The recursion goes **deep to the base case**, then **unwinds upward** computing actual results.




---

### ðŸ§  Function: `pow(x, n)` â†’ `temp(x, n)`  
We are calling `pow(2, 10)` â†’ which leads to `temp(2, 10)`

### ðŸ“ˆ Recursion Tree for `temp(2, 10)`

```
temp(2,10)
   |
   â””â”€â”€ temp(2,5)
         |
         â””â”€â”€ temp(2,2)
               |
               â””â”€â”€ temp(2,1)
                     |
                     â””â”€â”€ temp(2,0) â†’ returns 1
```

### ðŸ“¦ Returning Back:

Now we compute and return step by step:

```
temp(2,0) = 1
â†‘
temp(2,1):
  ans = 1
  n is odd â†’ return ans * ans * x = 1 * 1 * 2 = 2

â†‘
temp(2,2):
  ans = 2
  n is even â†’ return ans * ans = 2 * 2 = 4

â†‘
temp(2,5):
  ans = 4
  n is odd â†’ return ans * ans * x = 4 * 4 * 2 = 32

â†‘
temp(2,10):
  ans = 32
  n is even â†’ return ans * ans = 32 * 32 = 1024
```
![image](./Assets/Math_Pow(x,n).jpg)
---

### âœ… Final Result:
```
pow(2,10) = 1024
```

---

This recursion tree illustrates:
- **Call flow (top-down)**
- **Evaluation on return (bottom-up)**
- How each function waits for the result before executing the multiplication logic.


---