

# ğŸ“Œ **User Schema (Mongoose) â€” Full Code + Detailed Explanation**

---

# ğŸ§¾ **ğŸ“ User Schema Code **

```js
const userSchema = new mongoose.Schema({
    username : {
        type : String,
        required : true,
        unique : true
    },
    email : {
        type : String,
        required : true,
        unique : true
    },
    password : {
        type : String,
        select : false
    },
    fullName : {
        firstName : { type : String, required : true},
        lastName : { type : String, required : true}
    },
    role : {
        type : String,
        enum : [ "user", "seller" ],
        default : "user"
    },
    addresses : [ addressesSchema ]
})
```

---

# ğŸ“˜ **In-Depth Notes on the `userSchema` (Mongoose)**

---

## ğŸ”· **1. What is a Mongoose Schema?**

A **Mongoose Schema** defines the *shape/structure* of documents inside a MongoDB collection.
It acts like a blueprint that tells Mongoose:

* What fields a document should have
* How each field should be typed
* Which fields are required
* Validation rules
* Default values
* Subdocuments & embedded schemas

Your schema defines what a **User** document looks like in the database.

---

# ğŸ§© **2. Field-by-Field Deep Explanation**

---

## ğŸ”¹ **username**

```js
username : {
    type : String,
    required : true,
    unique : true
}
```

### âœ” Explanation:

* **String** â†’ stores text data.
* **required: true** â†’

  * The database *will not allow* saving a user without a username.
  * Ensures every user has a valid identifiable username.
* **unique: true** â†’

  * Creates a *unique index* in MongoDB.
  * Prevents two users from having the same username.
  * Useful for login systems or profile URLs.

ğŸ” **Purpose** â†’ Identity + duplicate protection.

---

## ğŸ”¹ **email**

```js
email : {
    type : String,
    required : true,
    unique : true
}
```

### âœ” Explanation:

* Works similarly to `username`.
* Acts as a unique user credential.
* Often used for:

  * Login
  * Email verification
  * Notifications

ğŸ“§ **Purpose** â†’ Ensures every email belongs to only *one* user.

---

## ğŸ”¹ **password**

```js
password : {
    type : String,
    select : false
}
```

### âœ” Explanation:

* Stores hashed passwords (**never plaintext!**)
* **select: false** â†’ Very important security feature:

  * Mongoose will **not** return the password field in queries.
  * Prevents accidental exposure.

Example:

```js
User.findOne({ email }) // password NOT included
```

To fetch explicitly:

```js
User.findOne({ email }).select("+password")
```

ğŸ¯ **Purpose** â†’ Prevents password leaks in API responses.
ğŸ” **Major security improvement**.

---

## ğŸ”¹ **fullName** (Embedded Object)

```js
fullName : {
    firstName : { type : String, required : true},
    lastName : { type : String, required : true}
}
```

### âœ” Explanation:

A **nested object** with first and last name.

Advantages:

* Structured data
* Better for sorting (e.g., by lastName)
* Easier search (e.g., by firstName)
* Cleaner organization

Both fields are required â†’ forces users to provide complete names.

---

## ğŸ”¹ **role**

```js
role : {
    type : String,
    enum : [ "user", "seller" ],
    default : "user"
}
```

### âœ” Explanation:

* Determines user **permissions** and **access level**.
* **enum** restricts allowed values.
* **default: "user"** â†’ user role set automatically if not specified.

ğŸ›¡ **Purpose** â†’ Basic role-based access control.
ğŸ”§ Example:

* `"user"` â†’ can browse/buy
* `"seller"` â†’ can list/manage products

---

## ğŸ”¹ **addresses**

```js
addresses : [ addressesSchema ]
```

### âœ” Explanation:

* An **array of subdocuments**.
* Each entry follows the structure defined in `addressesSchema`.
* Allows storing **multiple addresses** such as:

  * Home
  * Office
  * Billing
  * Shipping

ğŸ  **Purpose** â†’ Flexible system for storing multiple user addresses.

---

# ğŸ§  **3. How Mongoose Handles Validation**

Mongoose validates:

* Required fields
* Types
* Enum values
* Unique index errors

This schema includes:

* Required â†’ username, email, fullName fields
* Enum â†’ role
* Unique â†’ username, email

---

# ğŸ›¡ **4. Security Considerations**

### â­ `select: false` on password

* Prevents password from appearing in results.
* Vital for secure authentication systems.
* Protects user data even if a developer forgets to hide it manually.

ğŸ›¡ **Always hash passwords using bcrypt before saving.**

---

# ğŸ§¬ **5. Schema Modularity & Clean Architecture**

Using **`addressesSchema`**:

* Encourages modularity
* Makes code reusable
* Keeps schema files cleaner
* Good practice for scalable applications

---

# ğŸ“ **6. Final Schema Structure Overview**

```
User
 â”œâ”€â”€ username (String, unique, required)
 â”œâ”€â”€ email (String, unique, required)
 â”œâ”€â”€ password (String, hidden)
 â”œâ”€â”€ fullName
 â”‚     â”œâ”€â”€ firstName (String, required)
 â”‚     â””â”€â”€ lastName  (String, required)
 â”œâ”€â”€ role (String, enum, default: "user")
 â””â”€â”€ addresses[] (array of address subdocuments)
```

---