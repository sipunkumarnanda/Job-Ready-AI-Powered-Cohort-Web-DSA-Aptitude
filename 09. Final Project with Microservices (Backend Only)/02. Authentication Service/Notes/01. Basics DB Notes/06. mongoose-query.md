

# üöÄ **Mongoose Deep Notes With Line-by-Line Explanation**

(Everything below includes examples + breakdown.)

---

# 1. `find()` ‚Äî Read Many Documents üîé

## ‚úÖ **Example**

```js
const notes = await Note.find({ author: userId, published: true })
                        .select('title content createdAt')
                        .sort({ createdAt: -1 })
                        .limit(20)
                        .lean();
```

## üìå **Line-by-Line Explanation**

### **1Ô∏è‚É£ `const notes = await Note.find({ author: userId, published: true })`**

* `Note.find(...)`

  * Calls the Mongoose model `Note`
  * Looks for **many documents** in the `notes` collection
  * Filtering using MongoDB filter `{ author: userId, published: true }`
* `author: userId`

  * Only notes created by this user
* `published: true`

  * Only published notes (filters drafts)
* `await`

  * Executes the query
  * Pauses execution until DB responds
  * Returns *array of documents* (or empty array)

---

### **2Ô∏è‚É£ `.select('title content createdAt')`**

* Tells MongoDB:
  ‚ÄúReturn ONLY these fields‚Äù
* Helps:

  * Reduce network payload
  * Protect sensitive fields
  * Increase speed
* `'title content createdAt'`

  * A string with space-separated field names

---

### **3Ô∏è‚É£ `.sort({ createdAt: -1 })`**

* Sorts results by time
* `-1` means **descending** (newest first)
* This sort is efficient **if an index exists** on `createdAt`

---

### **4Ô∏è‚É£ `.limit(20)`**

* Return maximum **20** docs
* Prevents returning thousands of results
* Protects API performance

---

### **5Ô∏è‚É£ `.lean()`**

* Converts Mongoose Documents ‚Üí plain JS objects
* Removes:

  * getters
  * virtuals
  * `.save()`
  * methods
* Gains:

  * Faster performance
  * Lower RAM usage

---

### **6Ô∏è‚É£ `;` / closing statement**

* Saves final array to `notes`.

---

# 2. `findOne()` ‚Äî Read One Document üîç

## ‚úÖ **Example**

```js
const profile = await User.findOne({ username: 'alice' }).select('-password');
```

## üìå **Line-by-Line Explanation**

### **1Ô∏è‚É£ `User.findOne({ username: 'alice' })`**

* Searches the `users` collection
* Returns **first matching** document
* `{ username: 'alice' }` checks equality

---

### **2Ô∏è‚É£ `.select('-password')`**

* `-password` excludes password
* Important because schema may use `select: false`, but we reinforce security

---

### **3Ô∏è‚É£ `await`**

* Execution waits for DB result.
* Returns:

  * User document
  * OR `null` if none

---

### **4Ô∏è‚É£ Assign to variable**

* Stores found document in `profile`.

---

# 3. `findById()` ‚Äî Get Document by `_id` üÜî

## ‚úÖ **Example**

```js
const doc = await Post.findById(postId);
```

## üìå **Explanation**

### **`Post.findById(postId)`**

* Shortcut for `{ _id: postId }`
* `postId` must be:

  * A valid MongoDB ObjectId string
  * Or an actual ObjectId instance
* If invalid ‚Üí **CastError**
* If valid but not found ‚Üí `null`

### **`await`**

* Executes query
* Saves result into `doc`

---

# 4. `updateOne()` ‚Äî Update First Matching Document üõ†Ô∏è

## ‚úÖ **Example**

```js
await User.updateOne({ _id: id }, { $set: { name: 'Bob' } });
```

## üìå **Line-by-Line Explanation**

### **1Ô∏è‚É£ `{ _id: id }`**

* Filter: update the user with this ID

---

### **2Ô∏è‚É£ `{ $set: { name: 'Bob' } }`**

* `$set` operator updates one or more fields
* Only modifies `name` field
* Does **not** replace entire doc

---

### **3Ô∏è‚É£ `await User.updateOne(...)`**

* Executes immediately
* Returns:

  * `{ acknowledged: true, matchedCount: 1, modifiedCount: 1, ... }`

---

### **4Ô∏è‚É£ No return document**

* Unlike `findOneAndUpdate`, this method does **not** return the updated document.

---

# 5. `findOneAndUpdate()` ‚Äî Update & Return Document üîÑ

## ‚úÖ Example

```js
const updated = await User.findOneAndUpdate(
  { email },
  { $set: { lastLogin: Date.now() } },
  { new: true, runValidators: true }
);
```

## üìå **Line-by-Line Explanation**

### **1Ô∏è‚É£ `User.findOneAndUpdate(`**

* Searches for **one** matching document
* Updates it in one atomic operation

---

### **2Ô∏è‚É£ Filter: `{ email }`**

* Finds user with this email
* Equivalent to `{ email: email }`

---

### **3Ô∏è‚É£ Update: `{ $set: { lastLogin: Date.now() } }`**

* Updates last login timestamp
* `$set` prevents whole document overwrite

---

### **4Ô∏è‚É£ Options `{ new: true, runValidators: true }`**

#### üîπ `new: true`

* Return the **updated document**
* Otherwise returns old (pre-update) doc

#### üîπ `runValidators: true`

* Ensures schema validation
* Default: `false`, so this is important

---

### **5Ô∏è‚É£ Result saved to `updated`**

* If found: updated user
* If not found: `null`

---

# 6. `create()` ‚Äî Create Document ‚ú®

## Example

```js
const user = await User.create({ email, password: hashed, fullName: { firstName, lastName } });
```

## Explanation

### **1Ô∏è‚É£ `User.create({...})`**

* Inserts new document
* Uses schema defaults
* Triggers:

  * `pre('save')`
  * `post('save')`

---

### **2Ô∏è‚É£ Fields provided**

* Email: unique string
* Password: stored hash
* fullName: nested object

  * First name
  * Last name

---

### **3Ô∏è‚É£ `await`**

* Waits for MongoDB to confirm insertion

---

### **4Ô∏è‚É£ `user` variable**

* Contains the saved document, including auto-generated `_id`

---

# 7. `insertMany()` ‚Äî Bulk Insert ‚ö°

## Example

```js
await Note.insertMany([{...}, {...}]);
```

## Explanation

### **1Ô∏è‚É£ Bulk insertion**

* Very fast
* Sends array of docs at once

### **2Ô∏è‚É£ No save hooks for individual docs**

* `pre('save')` does NOT run
* But `pre('insertMany')` does run

### **3Ô∏è‚É£ `{...}`**

* Each object is new note data

---

# 8. `deleteOne()` / `deleteMany()` ‚Äî Remove Docs üóëÔ∏è

## Example

```js
await User.deleteOne({ _id: id });
```

### Explanation

* Deletes first matching doc
* Returns `{ deletedCount: 1 }` or `{ deletedCount: 0 }`

---

# 9. Population ‚Äî `.populate()` üîó

## Example

```js
const note = await Note.findById(id)
                       .populate('author', 'fullName email')
                       .populate({ path: 'comments', options: { sort: { createdAt: -1 } }});
```

## Explanation

### **1Ô∏è‚É£ `.populate('author', 'fullName email')`**

* Replace `author: ObjectId`
  ‚Üí with entire user object
* Only include:

  * `fullName`
  * `email`

---

### **2Ô∏è‚É£ Second populate**

```js
.populate({
  path: 'comments',
  options: { sort: { createdAt: -1 } }
})
```

* `path: 'comments'`

  * Field that holds array of comment IDs

* `options.sort`

  * Sort comments by newest first

---

### **3Ô∏è‚É£ Final result**

* `note` now includes:

  * full author object
  * array of populated comment objects

---

# 10. Cursor Pagination ‚Äî Scalable Paging üìÑ

## Example

```js
const docs = await Note.find({ createdAt: { $lt: lastSeen } })
                       .sort({ createdAt: -1 })
                       .limit(20);
```

## Line-by-Line Explanation

### **1Ô∏è‚É£ `{ createdAt: { $lt: lastSeen } }`**

* Fetch notes OLDER than the last seen timestamp
* Efficient for large datasets

---

### **2Ô∏è‚É£ `.sort({ createdAt: -1 })`**

* Sort ensures consistency

---

### **3Ô∏è‚É£ `.limit(20)`**

* Only get next 20

---

### **4Ô∏è‚É£ No `.skip()`**

* Avoids expensive skipping through large collections
* Much more scalable

---

# 11. Aggregation ‚Äî Analytics Pipeline üßÆ

## Example

```js
const counts = await Note.aggregate([
  { $match: { author: userId } },
  { $project: { day: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } } } },
  { $group: { _id: "$day", count: { $sum: 1 } } },
  { $sort: { _id: 1 } }
]);
```

## Explanation (stage-by-stage)

### **Stage 1: `$match` ‚Äî filtering**

```js
{ $match: { author: userId } }
```

* Only notes by this user

---

### **Stage 2: `$project` ‚Äî extract day**

```js
{ day: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } } }
```

* Convert `createdAt` date ‚Üí string date like `2025-01-30`
* Creates new field `day`

---

### **Stage 3: `$group` ‚Äî count notes per day**

```js
{ _id: "$day", count: { $sum: 1 } }
```

* Groups all notes with same day
* Increments counter for each

---

### **Stage 4: `$sort` ‚Äî chronological**

```js
{ _id: 1 }
```

---

# 12. Bulk Write ‚Äî Multiple Operations ‚ö°

## Example

```js
await User.bulkWrite([
  { updateOne: { filter: { _id: id }, update: { $inc: { score: 5 } } } },
  { deleteOne: { filter: { inactive: true } } },
  { insertOne: { document: { name: 'x' } } }
]);
```

## Explanation

### **1Ô∏è‚É£ `updateOne`**

* Finds user by ID
* Increases `score` by +5
* `$inc` is atomic (safe from race conditions)

---

### **2Ô∏è‚É£ `deleteOne`**

* Removes a user if inactive

---

### **3Ô∏è‚É£ `insertOne`**

* Inserts new document `{ name: 'x' }`

---

### **Bulk write benefits**

* Extremely fast
* Single network round-trip
* Operations run in order

---

# 13. Error Handling ‚Äî CastError ‚ùå

## Example

```js
const user = await User.findById("invalid-id");
```

### Explanation

* Mongoose tries to convert `"invalid-id"` ‚Üí ObjectId
* Conversion fails ‚Üí `CastError`
* Must validate IDs before using them

---

# 14. Regex Query ‚Äî LIKE Search üîç

## Example

```js
const results = await Note.find({ title: /shop/i });
```

### Explanation

* `/shop/i` ‚Üí case-insensitive regex
* Finds:

  * ‚Äúshopping‚Äù
  * ‚ÄúShop Items‚Äù
  * ‚ÄúSHOP NOW‚Äù
* But **cannot use index** because regex has no anchor (`^` or `$`)

---

# 15. Text Search ‚Äî Ranked Search üîé

## Example

```js
const results = await Note.find(
  { $text: { $search: "shopping list" } },
  { score: { $meta: "textScore" } }
).sort({ score: { $meta: "textScore" } });
```

## Explanation

### **1Ô∏è‚É£ `$text: { $search: ... }`**

* Uses MongoDB text index
* Searches across all text-indexed fields

---

### **2Ô∏è‚É£ `{ score: { $meta: "textScore" } }`**

* Adds ranking score to results
* Higher = more relevant document

---

### **3Ô∏è‚É£ `.sort({ score: ... })`**

* Sorts by relevance

---

---


---



# üî• **PART 2 ‚Äî DEEP EXPLANATION OF REMAINING MONGOOSE METHODS & CONCEPTS**

---

# 16. `updateMany()` ‚Äî Update Multiple Docs üõ†Ô∏èüß©

## ‚úÖ **Example**

```js
await Note.updateMany(
  { archived: true },
  { $set: { visible: false } }
);
```

## üìå **Line-By-Line Breakdown**

### **1Ô∏è‚É£ Filter: `{ archived: true }`**

* Means:

  > Update all notes where the field `archived` is exactly `true`.

* If 1,000 notes have `archived: true`,
  ‚Üí This will affect ALL 1,000.

---

### **2Ô∏è‚É£ Update: `{ $set: { visible: false } }`**

* `$set` updates ONLY specified field.
* Does not change other fields.
* Sets `visible` to `false` for every matched note.

---

### **3Ô∏è‚É£ `await Note.updateMany(...)`**

* Executes update on server.
* Returns:

```js
{
  acknowledged: true,
  matchedCount: <num docs>,
  modifiedCount: <num docs>
}
```

---

### ‚ö†Ô∏è **Important Notes / Warnings**

* **Dangerous command**, because:

  * Updates large numbers of docs
  * No ‚Äúreturn updated doc‚Äù option
* **No validation unless `runValidators: true`**
* Does NOT trigger:

  * `save()` hooks
  * pre/post save middleware
* Should be used for admin or internal operations
  (not usually in user-facing APIs)

---

# 17. `deleteMany()` ‚Äî Delete Many Documents üóëÔ∏è‚ö†Ô∏è

## ‚úÖ Example

```js
await User.deleteMany({ inactive: true });
```

## üìå Explanation

### **1Ô∏è‚É£ Filter `{ inactive: true }`**

* Deletes all users with inactive flag set.

---

### **2Ô∏è‚É£ `await User.deleteMany(...)`**

* Immediate execution.
* Returns:

```js
{ acknowledged: true, deletedCount: <number> }
```

---

### ‚ö†Ô∏è Be VERY careful

* `{}` as filter deletes **entire collection**.
* No confirmation, no safety checks.

---

# 18. `findOneAndDelete()` / `findByIdAndDelete()` üóëÔ∏èüîç

## Example

```js
const deletedUser = await User.findByIdAndDelete(id);
```

## Explanation

### **1Ô∏è‚É£ `User.findByIdAndDelete(id)`**

* Looks for a user with this `_id`.
* Deletes that user.
* Returns:

  * Deleted document
  * OR `null` if not found

---

### **2Ô∏è‚É£ Why use this instead of `deleteOne`?**

Because it **returns the deleted object**.

Useful when:

* You need to show deleted record in logs
* You need data before deletion
* You want to remove associated files or references

---

# 19. Regex, LIKE Queries ‚Äî Pattern Matching üîçüßµ

## Example

```js
const matches = await Product.find({ name: /iphone/i });
```

## Explanation

### **1Ô∏è‚É£ `/iphone/i`**

* A regular expression
* `i` means "case-insensitive"

Matches:

* "iPhone"
* "IPHONE 14"
* "iphone charger"

---

### **2Ô∏è‚É£ `{ name: /iphone/i }`**

* Search in the `name` field
* Regex prevents index usage unless anchored

---

### ‚ö†Ô∏è Performance Warning

* Regex without `^` is slow
* Scans entire collection
* Use with caution

---

## ‚ö° Fast Regex Example (uses index)

```js
{ name: /^iphone/i }
```

* Anchored (`^`)
* Uses index on `name`

---

# 20. Logical Operators ‚Äî `$or`, `$and`, `$nor` üß†

## Example

```js
const results = await Note.find({
  $or: [
    { title: /urgent/i },
    { tags: "important" }
  ]
});
```

## Breakdown

### **1Ô∏è‚É£ `$or: [...]`**

* Means:

  > Return docs where ANY condition is true

---

### **2Ô∏è‚É£ `{ title: /urgent/i }`**

* Matches notes with ‚Äúurgent‚Äù in title

---

### **3Ô∏è‚É£ `{ tags: "important" }`**

* Matches notes whose `tags` array contains word `"important"`

---

### Result:

Notes with:

* Urgent title
* OR important tag

---

# 21. Array Queries ‚Äî Powerful Operators üì¶

## Example

```js
const notes = await Note.find({
  tags: { $all: ["javascript", "backend"] }
});
```

## Explanation

### **1Ô∏è‚É£ `tags: { $all: [...] }`**

* Document's `tags` array must include **both** values
* Order doesn't matter

---

# 22. `$elemMatch` ‚Äî Match Inside Arrays üéØ

## Example

```js
const orders = await Order.find({
  items: { $elemMatch: { price: { $gt: 500 }, quantity: { $gte: 2 } } }
});
```

## Explanation

### **1Ô∏è‚É£ `items` field**

* Array of objects (cart-like data)

---

### **2Ô∏è‚É£ `$elemMatch`**

* At least one element in array must satisfy:

  * price > 500
  * quantity >= 2

---

### **Why use `$elemMatch`?**

Because:

```js
items: { price: { $gt: 500 }, quantity: { $gte: 2 } }
```

Would WRONGFULLY match if:

* One item has price > 500
* Another item has quantity >= 2

Must be same element ‚Üí `$elemMatch`

---

# 23. `countDocuments()` ‚Äî Exact Count üßÆ

## Example

```js
const total = await User.countDocuments({ active: true });
```

## Explanation

### **1Ô∏è‚É£ Counts docs matching filter**

* `{ active: true }`

### **2Ô∏è‚É£ Accurate but slower**

* Must scan index completely
* Cannot estimate

---

# 24. `estimatedDocumentCount()` ‚Äî Fast Count ‚ö°

## Example

```js
const approx = await User.estimatedDocumentCount();
```

### Explanation

* Very fast
* Does NOT apply filters
* Uses collection metadata

Good for:

* Dashboard quick metrics
* Rough estimates
  Not for:
* Exact counts
* Filtered counts

---

# 25. Population ‚Äî Advanced Concepts üîóüß¨

We already covered simple populate.
Now here‚Äôs more advanced usage.

---

## Advanced Example

```js
const post = await Post.findById(postId)
  .populate({
    path: "author",
    select: "fullName email",
    match: { banned: false },
  })
  .populate({
    path: "comments",
    populate: {
      path: "user",
      select: "username profilePic"
    }
  });
```

## In-Depth Explanation

---

### **1Ô∏è‚É£ `.populate({ path: "author" })`**

* Look in `author` field
* Replace ObjectId ‚Üí user document

---

### **2Ô∏è‚É£ `select: "fullName email"`**

* Only include these two fields in populated author

---

### **3Ô∏è‚É£ `match: { banned: false }`**

* Populate only if the author is not banned
* If banned ‚Üí `author` becomes `null`

---

### **4Ô∏è‚É£ Nested Populate**

```js
.populate({
  path: "comments",
  populate: {
    path: "user",
    select: "username profilePic"
  }
})
```

* Populate `comments`
* THEN populate `user` inside each comment
  ‚Üí two-level deep populate

---

# 26. Cursors ‚Äî Stream Results ‚öôÔ∏èüîÑ

## Example

```js
const cursor = Note.find({}).cursor();
for await (const doc of cursor) {
  console.log(doc.title);
}
```

## Explanation

### **1Ô∏è‚É£ `.cursor()`**

* Creates a MongoDB cursor
* Streams results in small batches
* Does NOT load all docs into memory

---

### **2Ô∏è‚É£ `for await (...)`**

* Async iteration
* Reads one doc at a time
* Good for:

  * Large exports
  * Migrating millions of records

---

### ‚ö†Ô∏è Memory Safe

* Perfect for large-scale data processing

---

# 27. Transactions ‚Äî ACID Operations üîê

## Full Example

```js
const session = await mongoose.startSession();
await session.withTransaction(async () => {
  await User.updateOne(
    { _id: sender },
    { $inc: { balance: -50 } },
    { session }
  );

  await User.updateOne(
    { _id: receiver },
    { $inc: { balance: 50 } },
    { session }
  );
});
session.endSession();
```

## Line-by-Line Explanation

### **1Ô∏è‚É£ Start a session**

```js
const session = await mongoose.startSession();
```

* Session used to manage transaction state

---

### **2Ô∏è‚É£ Begin transaction**

```js
await session.withTransaction(async () => { ... });
```

* Everything inside must succeed
* If one operation fails ‚Üí ALL rolled back

---

### **3Ô∏è‚É£ Update sender**

```js
{ $inc: { balance: -50 } }
```

* Atomically subtract 50

---

### **4Ô∏è‚É£ Update receiver**

```js
{ $inc: { balance: 50 } }
```

---

### **5Ô∏è‚É£ `{ session }`**

* REQUIRED
* Operation belongs to this transaction

---

### **6Ô∏è‚É£ `session.endSession()`**

* Clean up resources

---

# 28. `.lean()` ‚Äî Why It‚Äôs Important ‚ö°

## Example

```js
const notes = await Note.find().lean();
```

### Explanation

* Converts Mongoose documents ‚Üí plain JavaScript objects
* Removes overhead:

  * getters
  * virtuals
  * methods
  * change tracking
* Huge performance boost:

  * 3√ó faster queries
  * 2‚Äì3√ó less memory

---

# 29. Pagination ‚Äî Skip/Limit vs Cursor üìÑ

## Skip/Limit Example

```js
Note.find().skip(1000).limit(20)
```

### Problems:

* Skip 1000 = database must walk 1000 records
* Slow on large collections
* Bad for infinite scroll

---

## Cursor Example

```js
Note.find({ createdAt: { $lt: lastSeen } })
```

### Benefits:

* No skip
* High performance
* Works with index
* Best for infinite scroll / feed systems

---

# 30. Indexing ‚Äî HOW & WHY ‚öôÔ∏è

## Example

```js
NoteSchema.index({ author: 1, createdAt: -1 });
```

### Explanation

* Compound index
* Optimizes queries that filter by author AND sort by createdAt
* MongoDB reads one index tree
* Much faster than scanning data

---

# 31. `.explain()` ‚Äî Debug Queries üõ†Ô∏è

## Example

```js
const plan = await Note.find({ title: /shop/i }).explain();
```

### Explanation

* Shows how MongoDB plans to execute query
* Look for:

  * `IXSCAN` (good)
  * `COLLSCAN` (bad)

---



---
---
---

# üöÄ **PART 3 ‚Äî MONGOOSE ADVANCED NOTES (Fully In Depth)**

---

# 32. Mongoose Middleware ‚Äî The Heart of Mongoose üíìüß†

Mongoose middleware allows you to execute logic **before or after** certain operations.

### Two types:

1. **Document middleware** ‚Üí triggered by document operations (`save`, `remove`, `validate`)
2. **Query middleware** ‚Üí triggered by query operations (`find`, `updateOne`, `findOneAndUpdate`, etc.)

---

# 32.1 Document Middleware (`pre` / `post`) üìÑ

## Example ‚Äî Hashing password before saving

```js
UserSchema.pre("save", async function (next) {
  if (!this.isModified("password")) return next();
  this.password = await bcrypt.hash(this.password, 12);
  next();
});
```

## Line-by-line explanation

### **1Ô∏è‚É£ `UserSchema.pre("save", ...)`**

* Run this function **before** document is saved
* Applies ONLY when calling:

  * `document.save()`
  * `Model.create()`
* DOES NOT run during:

  * `updateOne`
  * `findOneAndUpdate`
  * `findByIdAndUpdate`

---

### **2Ô∏è‚É£ `async function(next)`**

* Mongoose passes a callback `next`
* You MUST call `next()` or return a Promise (via `async`)

---

### **3Ô∏è‚É£ `if (!this.isModified("password")) return next();`**

* `this` refers to the actual document
* Prevents re-hashing password every time user is saved
* Only hash on:

  * initial creation
  * password change

---

### **4Ô∏è‚É£ `this.password = await bcrypt.hash(...)`**

* Replaces plain password with secure hash

---

### **5Ô∏è‚É£ `next()`**

* Required to tell Mongoose to continue

---

# 32.2 Post-save Middleware

```js
UserSchema.post("save", function (doc, next) {
  console.log("User saved:", doc.email);
  next();
});
```

### Explanation

* Runs AFTER saving
* Good for:

  * Logging
  * Triggering background jobs
  * Sending admin alerts

Not good for:

* Sending emails
  (should be done in queues, not sync)

---

# 32.3 Query Middleware ‚Äî "pre find" üß†

## Example ‚Äî Automatically exclude soft-deleted docs

```js
UserSchema.pre(/^find/, function (next) {
  this.where({ deleted: { $ne: true } });
  next();
});
```

### Explanation

---

### **1Ô∏è‚É£ `pre(/^find/)`**

* Applies to:

  * `find`
  * `findOne`
  * `findById`
  * `findOneAndUpdate`
* ANY query starting with "find"

---

### **2Ô∏è‚É£ `this.where(...)`**

* `this` refers to the actual query object
* Adding filter to **ALL** find queries

---

### **3Ô∏è‚É£ `{ deleted: { $ne: true } }`**

* Exclude users where `deleted = true`

---

### Benefit:

This implements **automatic soft-delete filtering** without repeating logic everywhere.

---

# 33. Schema Options ‚Äî Very Important Settings ‚öôÔ∏èüìò

When defining a schema, you can set global behaviors.

---

## Example

```js
const UserSchema = new Schema({
  email: String,
  password: String
}, {
  timestamps: true,
  versionKey: false,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});
```

## Line-by-line Explanation

---

### **1Ô∏è‚É£ `timestamps: true`**

* Automatically create:

  * `createdAt`
  * `updatedAt`
* Updated automatically on save/update

---

### **2Ô∏è‚É£ `versionKey: false`**

* Removes default `__v` field
* Mongo uses this version for conflict detection
* Safe to disable unless you rely on versioning

---

### **3Ô∏è‚É£ `toJSON: { virtuals: true }`**

* When converting document ‚Üí JSON (e.g., sending API response)
* Include virtual fields in output
* Very helpful for:

  * fullName virtuals
  * computed fields

---

### **4Ô∏è‚É£ `toObject: { virtuals: true }`**

* Same as above but for converting to plain object

---

---

# 34. Virtual Fields ‚Äî Fake Fields That Appear Real ü™Ñ

---

## Example ‚Äî fullName virtual

```js
UserSchema.virtual("fullName").get(function () {
  return `${this.firstName} ${this.lastName}`;
});
```

## Explanation

### **1Ô∏è‚É£ `.virtual("fullName")`**

* Creates a virtual attribute
* NOT stored in DB
* Only computed dynamically

---

### **2Ô∏è‚É£ `.get(function() {...})`**

* Getter runs when field is accessed
* Example:

```js
user.fullName // "John Doe"
```

---

### **3Ô∏è‚É£ Not included by default in JSON**

You must enable:

```js
toJSON: { virtuals: true }
```

---

### **Use cases**

* Create derived fields
* Combine multiple properties
* Format output
* Compute totals (cart totals, etc.)

---

# 35. Custom Schema Methods ‚Äî Instance Methods üß†

These are methods available on **documents**, not models.

---

## Example ‚Äî Compare password

```js
UserSchema.methods.comparePassword = function (candidate) {
  return bcrypt.compare(candidate, this.password);
};
```

## Explanation

### **1Ô∏è‚É£ `.methods.comparePassword`**

* Adds method to document prototype
* Called on actual document instance

---

### **2Ô∏è‚É£ `this.password`**

* Access to raw document data

---

### **Usage:**

```js
const user = await User.findOne({ email }).select("+password");
if (await user.comparePassword(inputPassword)) {
  // login
}
```

---

# 36. Static Methods ‚Äî Model-Level üèõÔ∏è

---

## Example

```js
UserSchema.statics.findActive = function () {
  return this.find({ active: true });
};
```

### Explanation

---

### **1Ô∏è‚É£ `.statics`**

* Adds method to model itself (not documents)

---

### **2Ô∏è‚É£ `return this.find({ active: true })`**

* `this` refers to the model (User)

---

### **Usage**

```js
const users = await User.findActive();
```

---

# 37. Query Helpers ‚Äî Custom Helpers for Queries üß©

---

## Example

```js
UserSchema.query.byEmail = function (email) {
  return this.where({ email: new RegExp(email, "i") });
};
```

## Explanation

### **1Ô∏è‚É£ `.query.byEmail`**

* Extend the query prototype
* Can chain this with find

---

### **2Ô∏è‚É£ `return this.where(...)`**

* Modify the current query with filter

---

### Usage

```js
const user = await User.find().byEmail("john@example.com");
```

---

# 38. Model vs Document vs Query ‚Äî VERY IMPORTANT üß±

## Model-level operations:

* `find`
* `findOne`
* `updateOne`
* `deleteMany`
* `insertMany`
* `aggregate`

‚ö†Ô∏è These DO NOT run document middleware (like `save`).

---

## Document-level operations:

* `document.save()`
* `document.validate()`
* `document.remove()`

These DO run:

* `pre('save')`
* `post('save')`

---

## Query-level operations:

* `find`
* `findOneAndUpdate`
* `updateOne`
* `deleteOne`

These trigger:

* `pre('find')`
* `pre('updateOne')`
* etc.

---

# 39. Document Lifecycle ‚Äî Complete Breakdown üß¨

---

### When you create a document:

1. Construct document
2. Validate
3. Run `pre('save')`
4. Save to database
5. Run `post('save')`

---

### When you update with `findOneAndUpdate`:

1. Does NOT fetch full document
2. NO `save()` triggers
3. NO validation unless `runValidators: true`
4. NO middleware except `pre('findOneAndUpdate')`

---

### When you use `updateOne`

* No document is created
* No validation (unless asked)
* No middleware except `pre('updateOne')`

---

# 40. Query Optimization ‚Äî Make Queries FAST ‚ö°üöÄ

---

## 40.1 Use Lean

```js
Model.find().lean();
```

üß† Why?

* Faster
* Less RAM
* No Mongoose overhead

Use for:

* Read-only endpoints
* Large lists

---

## 40.2 Use Proper Indexes

```js
Schema.index({ email: 1 });
```

Always index:

* lookup fields
* fields used in search
* fields used in sort
* fields in pagination

---

## 40.3 Avoid `$regex: ".*something.*"`

Because:

* NO index usage
* Full collection scan
* Potential DoS attack

---

## 40.4 Use Projection

```js
.select("name email")
```

Returns:

* Smaller documents
* Faster query
* Lower network load

---

## 40.5 Use `.explain()` to debug

```js
.find().explain("executionStats")
```

Look for:

* `IXSCAN` = GOOD
* `COLLSCAN` = BAD

---

# 41. Real-World Pattern ‚Äî Soft Delete üóÉÔ∏è

---

## Schema

```js
deleted: { type: Boolean, default: false }
```

## Query middleware

```js
UserSchema.pre(/^find/, function (next) {
  this.where({ deleted: false });
  next();
});
```

## Delete user

```js
await User.findByIdAndUpdate(id, { deleted: true });
```

‚úî Fast
‚úî Reversible
‚úî Data preserved
‚úî No accidental hard delete

---

# 42. Real-World Pattern ‚Äî Auto-Filtering Private Fields üîê

## Schema

```js
password: { type: String, select: false }
```

## Login

```js
const user = await User.findOne({ email }).select("+password");
```

‚úî Prevents accidental exposure
‚úî Only include password when needed

---

# 43. Real-World Pattern ‚Äî Role-Based Access Control (RBAC) üõ°Ô∏è

---

## Field

```js
role: { type: String, enum: ["user", "admin"], default: "user" }
```

## Middleware

```js
function requireAdmin(req, res, next) {
  if (req.user.role !== "admin") {
    return res.status(403).json({ message: "Forbidden" });
  }
  next();
}
```

---

# 44. Real-World Pattern ‚Äî Pre-Fill Defaults üßä

```js
schema.pre("save", function (next) {
  if (!this.createdAt) this.createdAt = Date.now();
  next();
});
```

---