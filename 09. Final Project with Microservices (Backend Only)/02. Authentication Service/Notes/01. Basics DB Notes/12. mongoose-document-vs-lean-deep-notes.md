


### üß© **Mongoose: Document vs Plain JS Object (`.lean()`)**


## üèó 1. What is Mongoose? What is a Document? What is `.lean()`?

### üß† Mongoose in one sentence

**Mongoose** is a library that helps you talk to MongoDB from Node.js.
It adds:

* Schemas (structure for your data)
* Validation
* Middleware/hooks
* Helper methods (like `.save()`, `.find()`, etc.)

### üìÑ What is a **Mongoose Document**?

A **Document** is:

* A **single record** from MongoDB
* Wrapped (‚Äúhydrated‚Äù) by Mongoose into a **rich object**
* Has **methods and behaviors**, e.g.:

  * `.save()`
  * `.isModified()`
  * virtuals
  * getters/setters
  * middleware (pre-save, etc.)

So: **Document = MongoDB row + extra Mongoose powers.**

### üì¶ What is a **Plain JS Object (POJO)**?

A **POJO** is just a normal JavaScript object like:

```js
{
  _id: 'u1',
  name: 'Alex',
  email: 'alex@mail.com'
}
```

No hidden powers. No `.save()`. No tracking. Just data.

### ‚öôÔ∏è What does `.lean()` do?

When you call `.lean()` on a query:

* You tell Mongoose: **‚ÄúDon‚Äôt hydrate. Give me plain objects.‚Äù**
* So instead of a **Document**, you get a **POJO**.
* Faster and lighter, but **no document methods**, **no middleware**, **no virtuals** (by default).

---

## üß© 2. Document Example ‚Äî With Line-by-Line Explanation

### ‚úÖ Code: Using a **Document** (no `.lean()`)

```js
const userDoc = await User.findById('u1'); // no .lean()
userDoc.name = 'Bob';

console.log(typeof userDoc.save);         // "function"
console.log(userDoc.isModified('name'));  // true

await userDoc.save();
```

### üßµ Line-by-line breakdown

#### 1Ô∏è‚É£

```js
const userDoc = await User.findById('u1'); // no .lean()
```

* `User` ‚Üí This is your **Mongoose model** created from `UserSchema`.
* `.findById('u1')` ‚Üí Asks MongoDB for the document with `_id = 'u1'`.
* `await` ‚Üí Waits until the database responds.
* **No `.lean()`** ‚Üí Mongoose will **hydrate** the raw MongoDB object into a **Mongoose Document**.
* Result: `userDoc` is **NOT** a plain object; it‚Äôs an instance of Mongoose‚Äôs `Document`.

#### 2Ô∏è‚É£

```js
userDoc.name = 'Bob';
```

* You change the `name` field **in memory**.
* Mongoose notices this change and marks `name` as **modified** internally (dirty tracking).

#### 3Ô∏è‚É£

```js
console.log(typeof userDoc.save); // "function"
```

* You‚Äôre checking what `userDoc.save` is.
* Output `"function"` means:

  * `userDoc` has a **`.save()` method**.
  * This proves `userDoc` is a **Mongoose Document**, not a plain object.

#### 4Ô∏è‚É£

```js
console.log(userDoc.isModified('name')); // true
```

* `.isModified('name')` asks Mongoose:

  > ‚ÄúHas the `name` field changed compared to the version from the DB?‚Äù
* It returns `true` because you changed `name` from the original value (`Alex`) to `Bob`.

#### 5Ô∏è‚É£

```js
await userDoc.save();
```

When you call `.save()` on a Document, Mongoose:

1. Runs **validators** (e.g. `required`, `minLength`, custom validators).
2. Runs **pre('save') middleware** (e.g. hashing password, updating timestamps).
3. Sends an **update** to MongoDB with only the modified fields.
4. Runs **post('save') middleware** (e.g. logging, side effects).

So `.save()` is not just a DB write ‚Äî it‚Äôs a whole **lifecycle**.

---

## üì¶ 3. Plain Object Example ‚Äî Using `.lean()`

### ‚úÖ Code: Using `.lean()` to get a POJO

```js
const userObj = await User.findById('u1').lean();

console.log(userObj.save); // undefined

userObj.name = 'Bob';      // modify in-memory only
// cannot call userObj.save(); // will crash if you try
```

### üßµ Line-by-line breakdown

#### 1Ô∏è‚É£

```js
const userObj = await User.findById('u1').lean();
```

* Similar to before, but now:

  * `.lean()` is attached to the query.
* This tells Mongoose:

  > ‚ÄúDo not create a Document. Give me the raw MongoDB result as a plain JS object.‚Äù
* The result: `userObj` is a **POJO**, not a Mongoose Document.

#### 2Ô∏è‚É£

```js
console.log(userObj.save); // undefined
```

* You check `.save` on this object.
* Because it‚Äôs just an object, there is **no `.save()` function.**
* Output ‚Üí `undefined`.
* This proves: **lean ‚Üí no document methods.**

#### 3Ô∏è‚É£

```js
userObj.name = 'Bob';
```

* You can still modify the object in code.
* But this **does NOT tell Mongoose** anything.
* No change tracking, no validation, no DB write yet.

#### Important ‚ö†Ô∏è

There‚Äôs **no**:

```js
await userObj.save(); // ‚ùå this does not exist
```

To persist changes, you must use a **Model-level update method**, like:

```js
await User.updateOne({ _id: 'u1' }, { $set: { name: 'Bob' } });
```

---

## üö´ 4. Common Mistake ‚Äî Calling `.save()` on Lean Result

### ‚ùå Wrong Code

```js
const user = await User.findOne({ email: 'a@mail.com' }).lean();

user.age = 31;
await user.save(); // ‚ùå TypeError: user.save is not a function
```

### Why this fails

* `user` is a **plain object**.
* `.lean()` strips out all Mongoose document features.
* So calling `.save()` causes an error because `.save` is **undefined**.

### ‚úÖ Correct Pattern 1: Use Update Query

```js
await User.updateOne(
  { email: 'a@mail.com' },      // find this user
  { $set: { age: 31 } }         // update age to 31
);
```

**Explanation:**

* `updateOne` tells MongoDB directly: ‚ÄúFind document matching this filter and set these fields.‚Äù
* No document hydration.
* No `.save()`.
* Good for performance, especially when you don‚Äôt need hooks or validation.

### ‚úÖ Correct Pattern 2: Re-fetch as Document

```js
const userDoc = await User.findOne({ email: 'a@mail.com' }); // no .lean()
userDoc.age = 31;
await userDoc.save();
```

**When to use this:**

* You want **middleware** (like password hashing) to run.
* You want **schema validation** checked.
* You want **pre/post-save logic**.

---

## ‚ú® 5. Virtuals ‚Äî Computed Fields (Not Stored in DB)

### üßæ Idea

A **virtual** is a property that:

* **Does not exist** in the database.
* Is **computed on the fly** when you access it.
* Example: `fullName` from `firstName` + `lastName`.

---

### ‚úÖ Schema Example with Virtual

```js
const UserSchema = new mongoose.Schema({
  firstName: String,
  lastName: String,
  password: { type: String, select: false }
});

// define virtual
UserSchema.virtual('fullName').get(function () {
  return `${this.firstName} ${this.lastName}`;
});

// include virtuals when converting
UserSchema.set('toObject', { virtuals: true });
UserSchema.set('toJSON', { virtuals: true });

const User = mongoose.model('User', UserSchema);
```

### üßµ Line-by-line breakdown

#### 1Ô∏è‚É£

```js
const UserSchema = new mongoose.Schema({
  firstName: String,
  lastName: String,
  password: { type: String, select: false }
});
```

* You define a schema for User.
* `firstName`, `lastName` ‚Üí simple string fields.
* `password`:

  * `select: false` means **by default**, queries will **not include** `password` field unless you explicitly ask for it (security feature).

#### 2Ô∏è‚É£

```js
UserSchema.virtual('fullName').get(function () {
  return `${this.firstName} ${this.lastName}`;
});
```

* `virtual('fullName')` ‚Üí creates a **virtual field** named `fullName`.
* `.get(function () { ... })`:

  * Defines what happens when you access `doc.fullName`.
  * `this` is the **Document**.
  * It returns a string combining `firstName` + `lastName`.

> ‚ö†Ô∏è `fullName` is NOT in MongoDB. It‚Äôs computed from existing fields.

#### 3Ô∏è‚É£

```js
UserSchema.set('toObject', { virtuals: true });
UserSchema.set('toJSON', { virtuals: true });
```

* When you call:

  * `doc.toObject()` or `doc.toJSON()`
* These options tell Mongoose:

  > ‚ÄúInclude virtual fields (like `fullName`) in the resulting plain objects/JSON.‚Äù

#### 4Ô∏è‚É£

```js
const User = mongoose.model('User', UserSchema);
```

* You turn the schema into a **Model** you can use in your app.

---

### ‚úÖ Using the Virtual with a Document

```js
const userDoc = await User.findById('u1'); // no .lean()

console.log(userDoc.fullName); // "Alex Johnson"
res.json(userDoc);             // JSON will include fullName if toJSON virtuals are enabled
```

#### Explanation

* `userDoc.fullName` works because:

  * `userDoc` is a **Document**.
  * Virtuals are defined on the schema and available on documents.
* `res.json(userDoc)`:

  * Express calls `.toJSON()` internally.
  * Because you set `{ virtuals: true }`, `fullName` is included in the output.

---

## üßÆ 6. Virtuals + `.lean()` ‚Äî Important Behavior

By default:

* `.lean()` **does NOT include virtuals**.
* You get only the fields from the database.

### Example

```js
const users = await User.find().lean();
console.log(users[0].fullName); // undefined
```

To include something like `fullName` with `lean()` you have options:

### ‚úÖ Option 1: Compute manually

```js
const users = await User.find().select('firstName lastName').lean();

const withFullName = users.map(u => ({
  ...u,
  fullName: `${u.firstName} ${u.lastName}`
}));
```

* You take the plain objects and **add `fullName` yourself**.

### ‚úÖ Option 2: Use a plugin (conceptual)

With a plugin like `mongoose-lean-virtuals`, you can do:

```js
UserSchema.plugin(require('mongoose-lean-virtuals'));

const users = await User.find().lean({ virtuals: true });
console.log(users[0].fullName); // now works
```

> üìù Exact plugin usage can vary by version, but concept is:
> ‚ÄúLet `.lean()` also attach virtuals to the POJO.‚Äù

---

## üß∞ 7. Getters, Setters, and Transforms ‚Äî and `.lean()`

### üß© Getters Example (Always Lowercase Email)

```js
UserSchema.path('email').get(function (v) {
  return v ? v.toLowerCase() : v;
});
```

* `path('email')` ‚Üí gets the schema path for `email`.
* `.get(...)` ‚Üí defines a **getter**: a function that runs whenever you access `doc.email`.
* It ensures you always see `email` in lowercase.

#### With Document:

```js
const userDoc = await User.findById('u1');
console.log(userDoc.email); // "alex@mail.com"
```

* Getter runs ‚Üí value is lowercased.

#### With `.lean()`:

```js
const userObj = await User.findById('u1').lean();
console.log(userObj.email); // may be "Alex@Mail.com" (raw stored value)
```

* By default, **getters do NOT run** with `.lean()`.
* Some Mongoose versions support:
  `.lean({ getters: true })`, but behavior can vary and you should test.

---

### üîß `toJSON` / `toObject` Transforms (Hiding Passwords etc.)

Transform functions allow you to **modify the final object** before it‚Äôs sent out (for example, via API).

#### Example: Hide password, rename `_id` to `id`

```js
UserSchema.set('toJSON', {
  virtuals: true,
  transform(doc, ret) {
    delete ret.password;  // remove password
    ret.id = ret._id;     // add id alias
    delete ret._id;       // remove _id
    return ret;
  }
});
```

* `virtuals: true` ‚Üí include virtuals in JSON.
* `transform(doc, ret)`:

  * `doc` ‚Üí the original Document.
  * `ret` ‚Üí the plain object that will be returned.
  * You modify `ret` before sending.

#### With Document:

```js
const userDoc = await User.findById('u1');
res.json(userDoc);
```

* Express calls `.toJSON()` on `userDoc`.
* Transform runs:

  * `password` removed.
  * `_id` renamed to `id`.
  * `fullName` (virtual) included.
* Safer output to client.

#### With `.lean()`:

```js
const user = await User.findById('u1').lean();
res.json(user);
```

* `.lean()` returns a **plain object** already.
* `toJSON` transform **does not run**.
* `password` will **still be present** unless:

  * You use `select: false`, or
  * You manually `.select('-password')`.

‚úÖ So for `.lean()` queries, **you must handle sensitive fields manually.**

---

## ‚úÖ 8. Best Practices & Patterns (Practical Cheat List)

### ‚úÖ When to use **Documents (no `.lean()`)**

Use full **Mongoose Documents** when:

* You will call `.save()` on them.
* You rely on:

  * `pre('save')` / `post('save')` hooks.
  * Validation logic.
  * Complex virtuals or getters.
* You‚Äôre updating a small number of documents and care about business logic, not just raw performance.

---

### ‚úÖ When to use **`.lean()` (POJOs)**

Use `.lean()` when:

* Read-only endpoints (GET APIs).
* Large lists / feeds / dashboards.
* Bulk reads where you don‚Äôt call `.save()` on the results.
* You want:

  * Less memory usage.
  * Faster response times.
  * Lighter objects.

Example:

```js
const posts = await Post.find({ published: true })
  .select('title excerpt author')
  .populate('author', 'name avatarUrl')
  .sort({ createdAt: -1 })
  .limit(20)
  .lean();
```

Line-by-line:

* `.find({ published: true })` ‚Üí only published posts.
* `.select('title excerpt author')` ‚Üí return only these fields.
* `.populate('author', 'name avatarUrl')` ‚Üí replace `author` ID with user object (only name & avatar).
* `.sort({ createdAt: -1 })` ‚Üí newest first.
* `.limit(20)` ‚Üí only 20 posts.
* `.lean()` ‚Üí return all results as **plain objects**, not Documents.

---

### ‚úÖ Pagination Tips

* Simple pages ‚Üí use `.skip().limit()`:

  ```js
  Post.find().sort({ createdAt: -1 }).skip(page * size).limit(size).lean();
  ```
* Deep pagination (many pages) ‚Üí use **cursor/keyset pagination**:

  ```js
  Post.find({ createdAt: { $lt: lastCreatedAt } })
    .sort({ createdAt: -1 })
    .limit(20)
    .lean();
  ```

---

### üîê Hiding Sensitive Fields (Very Important)

* In schema:

  ```js
  password: { type: String, select: false }
  ```
* In queries:

  ```js
  .select('-password')
  ```
* Remember:

  * **Transforms (`toJSON`)** **do NOT apply** to `.lean()` results.
  * Always manually control what you send to the client when using `.lean()`.

---

## üßæ 9. Ultra-Compact Cheat Sheet (for Bottom of the Page)

```txt
-- Document vs POJO --
Document (no .lean):
  - Has .save(), .isModified(), hooks, validation
  - Virtuals + getters + toJSON/toObject transforms
  - Good for updates & business logic

POJO (.lean):
  - Plain object, no .save()
  - No hooks, no getters, no virtuals (by default)
  - Faster & lighter for read-only endpoints

-- Virtuals --
Schema.virtual('fullName').get(...)
Schema.set('toJSON', { virtuals: true })
Lean ignores virtuals unless plugin/manual compute.

-- Security --
password: { select: false }
Always .select('-password') on queries
Transforms do NOT run on lean, strip sensitive fields manually.

-- Rule of Thumb --
If you plan to mutate & save ‚Üí NO .lean()
If you just read & return ‚Üí USE .lean()
```

---