
# üß≠ AUTH MICROSERVICE 

---

## 1Ô∏è‚É£ OVERVIEW

**Purpose:**
The Auth microservice handles all user authentication and authorization logic for the Online Marketplace.
Its responsibilities include:

* User registration (`/register`)
* Login (`/login`)
* Logout (`/logout`)
* Fetching user profile (`/me`)
* Managing user addresses (`/addresses`)
* Issuing and verifying JWT tokens

**Why separate service:**

* Security isolation (only one place handles authentication)
* Independent scalability
* Can be reused by other microservices
* Easier maintenance and testing

**Type:**
Stateless RESTful microservice (token-based authentication)

**Tech Stack:**

* Node.js + Express
* MongoDB (via Mongoose)
* Redis (for token blacklist/session management)
* JWT for authentication
* Bcrypt for password hashing
* Jest + Supertest for TDD
* dotenv for configuration

**High-Level Flow:**

```
Client ‚Üí API Gateway ‚Üí Auth Service ‚Üí MongoDB
                 ‚Üì
        Other Services (verify token)
```

---

## 2Ô∏è‚É£ SYSTEM DESIGN & CONTEXT

**Role in System:**

* Entry point for user identity & access control.
* Issues tokens consumed by Product, Order, and Payment services.
* Ensures stateless verification (each service validates tokens independently).

**Data Flow Example (Login):**

1. Client sends credentials to Auth ‚Üí validated.
2. Auth verifies password (bcrypt) ‚Üí generates JWT.
3. JWT stored on client.
4. Other services verify JWT through `auth.middleware.js`.

**Redis Use Cases:**

* Blacklist access tokens on logout
* Store temporary data (like rate limiting or session caching)

**Scalability:**

* Stateless = horizontally scalable.
* Redis improves performance for frequent lookups.
* Can integrate into service mesh for distributed tracing later.

---

## 3Ô∏è‚É£ PROJECT STRUCTURE (inside `/src`)

```
src/
 ‚î£ controllers/
 ‚î£ db/
 ‚î£ middlewares/
 ‚î£ models/
 ‚î£ routes/
 ‚îó app.js
```

### Folder Responsibilities

* **controllers/** ‚Üí Handles logic for register, login, logout, me, addresses.
* **db/** ‚Üí Database connections (MongoDB & Redis).
* **middlewares/** ‚Üí Authentication & input validation.
* **models/** ‚Üí Mongoose models (e.g., User schema).
* **routes/** ‚Üí API endpoints mapped to controllers.
* **app.js** ‚Üí Entry point, mounts routes, starts server.

---

## 4Ô∏è‚É£ APP ENTRYPOINT ‚Äî `app.js`

**Purpose:**

* Initialize Express server.
* Connect to MongoDB and Redis.
* Mount middlewares and routes.
* Handle errors globally.

**Main Steps:**

1. Load `.env`
2. Connect to DBs
3. Parse JSON
4. Mount `/api/v1/auth` routes
5. Use error handler
6. Start server

**Important:**

* Do not start the server before DB connection is successful.
* Keep this file clean ‚Äî it should only wire dependencies.

---

## 5Ô∏è‚É£ ROUTES ‚Äî `src/routes/auth.routes.js`

**Purpose:**
Define API endpoints and map to controller functions.

**Endpoints:**

```
POST /register   ‚Üí registerUser
POST /login      ‚Üí loginUser
POST /logout     ‚Üí logoutUser
GET  /me         ‚Üí getCurrentUser
GET  /addresses  ‚Üí getUserAddresses
```

**Middlewares Applied:**

* `validator.middleware.js` ‚Üí input validation
* `auth.middleware.js` ‚Üí JWT verification for protected routes

**Principle:**
Routes should contain *no logic* ‚Äî just configuration.

---

## 6Ô∏è‚É£ CONTROLLERS ‚Äî `src/controllers/auth.controller.js`

**Purpose:**
Handle API logic and orchestrate model + middleware interaction.

**Key Functions:**

* **registerUser(req, res)**

  * Validate input.
  * Check if user exists.
  * Hash password, save to DB.
  * Generate JWT.
  * Return `{ user, token }`.

* **loginUser(req, res)**

  * Validate credentials.
  * Compare hashed passwords.
  * Generate JWT and return to client.

* **logoutUser(req, res)**

  * Extract token‚Äôs jti.
  * Add to Redis blacklist (TTL = token lifetime).
  * Return 204 (no content).

* **getCurrentUser(req, res)**

  * Read `req.user` (from auth middleware).
  * Return safe user data.

* **getUserAddresses(req, res)**

  * Fetch addresses from user model.

**Design Notes:**

* Keep token logic separate (possible future `tokenService`).
* Never return password.
* Errors handled via centralized middleware.

---

## 7Ô∏è‚É£ MIDDLEWARES

### (a) `auth.middleware.js`

**Purpose:**
Verifies JWT token for protected routes.

**Steps:**

1. Read `Authorization` header.
2. Extract token ‚Üí verify using `JWT_SECRET`.
3. Check Redis blacklist ‚Üí if found, reject request.
4. Attach user data to `req.user`.
5. Continue to next handler.

**Error Cases:**

* Missing token ‚Üí 401
* Expired token ‚Üí 401
* Blacklisted token ‚Üí 401

**Design Pattern:**
Single Responsibility ‚Äî only verifies token & attaches user.

---

### (b) `validator.middleware.js`

**Purpose:**
Validate request data before hitting controllers.

**Examples:**

* Register ‚Üí check required fields, password strength, email format.
* Login ‚Üí check for missing fields.

**On Validation Error:**
Respond with `422 Unprocessable Entity` and detailed field errors.

**Advantage:**
Keeps controllers clean and ensures input integrity.

---

## 8Ô∏è‚É£ DATABASE LAYER

### (a) `db/db.js`

**Purpose:**
Connect to MongoDB using Mongoose.

**Steps:**

* Load URI from `.env`.
* Connect with retry logic.
* Export connection instance.

**Best Practice:**
Handle DB connection before server start.

---

### (b) `db/redis.js`

**Purpose:**
Create Redis client for token blacklist and caching.

**Usage:**

* Logout ‚Üí add token to Redis blacklist.
* Check if token is blacklisted in auth middleware.

**Key Format Example:**
`blacklist:<token-id>` ‚Üí stored value ‚Äú1‚Äù, TTL = token expiry time.

**Additional Use:**
Login rate-limiting or caching user sessions.

---

## 9Ô∏è‚É£ MODELS ‚Äî `src/models/user.model.js`

**Purpose:**
Define Mongoose schema for users.

**Fields:**

```js
name: String,
email: { type: String, unique: true, lowercase: true },
password: String,
role: { type: String, default: "user" },
addresses: [Object]
```

**Pre-Save Hook:**

```js
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  this.password = await bcrypt.hash(this.password, saltRounds);
});
```

**Methods:**

* `comparePassword(plainPassword)` ‚Üí returns boolean.
* `toSafeJSON()` ‚Üí removes password before returning user object.

**Indexes:**

* `email` ‚Üí unique.

**Principle:**
Encapsulation ‚Äî hide internal password logic inside the model.

---

## üî¨ 10Ô∏è‚É£ TESTS ‚Äî (`__tests__` folder)

**Purpose:**
Guarantee correctness through TDD.

**Test Files & Focus:**

* `auth.register.test.js` ‚Üí user creation, validation, duplicate email
* `auth.login.test.js` ‚Üí correct/incorrect credentials
* `auth.logout.test.js` ‚Üí token blacklist
* `auth.me.test.js` ‚Üí authorized vs unauthorized access
* `auth.addresses.test.js` ‚Üí addresses endpoint (requires auth)

**Testing Stack:**

* Jest for testing
* Supertest for API calls
* In-memory MongoDB (optional) for isolation

**Test Lifecycle:**

```js
beforeAll(connectDB)
afterEach(clearDB)
afterAll(closeDB)
```

**Red ‚Üí Green ‚Üí Refactor Cycle:**
Write failing test ‚Üí implement ‚Üí pass ‚Üí refactor.

---

## 1Ô∏è‚É£1Ô∏è‚É£ DESIGN PRINCIPLES USED

1. **Separation of Concerns:**

   * Routes, controllers, and models have unique purposes.

2. **Single Responsibility:**

   * Each file focuses on one job.

3. **DRY (Don‚Äôt Repeat Yourself):**

   * Shared logic extracted to middleware or helpers.

4. **Encapsulation:**

   * Sensitive logic hidden (password hashing, JWT).

5. **Consistency:**

   * Uniform response format `{ success, data, error }`.

6. **Error Handling:**

   * Centralized error middleware ensures structured responses.

---

## 1Ô∏è‚É£2Ô∏è‚É£ COMMON ISSUES & FIXES

| Issue                     | Cause                         | Solution                       | Lesson                           |
| ------------------------- | ----------------------------- | ------------------------------ | -------------------------------- |
| 401 even with valid token | Token missing ‚ÄúBearer‚Äù prefix | Added check in auth.middleware | Always normalize token format    |
| Password not hashed       | Forgot pre-save hook          | Added bcrypt in user.model.js  | Encapsulate sensitive logic      |
| Tests failing randomly    | DB not cleaned                | Added `afterEach(deleteMany)`  | Keep test state isolated         |
| Duplicate user creation   | No unique index               | Added `unique: true`           | Always define unique constraints |
| Redis not connecting      | Wrong URI                     | Updated `.env`                 | Verify env setup early           |

---

## 1Ô∏è‚É£3Ô∏è‚É£ FUTURE IMPROVEMENTS

* Add **refresh tokens** with rotation.
* Implement **OAuth2 / Google login**.
* Add **RBAC middleware** (`requireRole('admin')`).
* Use **rate limiting** for login endpoint.
* Add **audit logs** for login/logout events.
* Split logic into **services layer** (`userService`, `tokenService`).
* Add caching layer for `/me` endpoint using Redis.
* Improve test coverage to 90%+.

---

## 1Ô∏è‚É£4Ô∏è‚É£ REFLECTION (Write This at the End)

**What I Learned:**

* How authentication fits in a microservice ecosystem.
* How to structure clean, layered code.
* How TDD improves code reliability.
* The importance of separating responsibilities.

**How I Can Reuse This:**

* The same pattern (controllers, routes, models) can be reused for Product, Order, or Payment services.
* Middleware and testing strategy are reusable templates for other APIs.

---