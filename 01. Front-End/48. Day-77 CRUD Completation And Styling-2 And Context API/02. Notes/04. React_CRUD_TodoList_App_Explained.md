
# CRUD Todo List App Explained — Step by Step

---

## 1. Overall Structure

Your app has 3 main parts:

* `App.jsx` — The **main component** that holds the state (todos) and renders two child components.
* `Create.jsx` — Component to **add new todos** (Create operation).
* `Read.jsx` — Component to **display and delete todos** (Read and Delete operations).

---

# Let’s dive into each file!

---

## App.jsx — Main Component & State Management

```jsx
import React, { useState } from "react";
import Create from "./components/Create";
import Read from "./components/Read";

const App = () => {
  const [todos, settodos] = useState([
    { id: 1, title: "Kaam Karle Bhai", isCompleted: false },
  ]);

  return (
    <div className="flex w-screen h-screen bg-gray-900 p-10 text-white">
      <Create settodos={settodos} todos={todos} />
      <Read settodos={settodos} todos={todos} />
    </div>
  );
};

export default App;
```

### Explanation:

* **State (`todos`)**:

  * `useState` is a React hook used to declare state in a functional component.
  * `todos` holds an array of todo objects.
  * Each todo has `{ id, title, isCompleted }`.
  * The initial state has one todo `{ id: 1, title: "Kaam Karle Bhai", isCompleted: false }`.

* **Why use state?**

  * React UI updates automatically when state changes.
  * Here, when todos change (add/delete), the UI updates to reflect it.

* **Passing props to children**:

  * `Create` and `Read` both receive `todos` and `settodos`.
  * This lets children read the todos and also update them by calling `settodos`.

* **Why split into components?**

  * Separation of concerns: Create handles adding todos; Read handles displaying and deleting.
  * Makes code cleaner, reusable, and easier to manage.

---

## Create.jsx — Adding New Todos (Create Operation)

```jsx
import { useState } from "react";
import { nanoid } from "nanoid";

const Create = (props) => {
  const settodos = props.settodos;
  const todos = props.todos;

  const [title, setTitle] = useState("");

  const submitHandler = (e) => {
    e.preventDefault();

    // Create new todo object
    const newTodoData = { id: nanoid(), title: title, isCompleted: false };

    // Add new todo to the existing list
    settodos([...todos, newTodoData]);

    // Clear input after submit
    setTitle("");
  };

  return (
    <div className=" w-[50%] p-10 flex flex-col ">
      <h1 className="mb-10 text-4xl text-white font-thin">
        Set <span className="text-red-400">Reminder</span> for <br /> tasks
      </h1>

      <form onSubmit={submitHandler} className="flex flex-col">
        <input
          className="p-2 border-b w-full text-2xl font-thin outline-0"
          onChange={(e) => setTitle(e.target.value)}
          value={title}
          type="text"
          placeholder="title"
        />
        <br /> <br />
        <button className="text-xl border py-2 w-[12rem] cursor-pointer rounded">
          Create Todo
        </button>
      </form>
    </div>
  );
};

export default Create;
```

### Explanation:

* **Local state `title`**:

  * `useState("")` is used to manage the input value inside the form.
  * Controlled component: The input field's value is tied to `title` state.
  * `onChange` updates the state whenever user types.

* **`submitHandler`**:

  * `e.preventDefault()` prevents page reload on form submit.
  * A new todo object is created with a unique `id` generated by `nanoid()`.
  * New todo is added to the existing `todos` array using spread `[...todos, newTodoData]`.
  * The `settodos` function from props updates the parent state in `App`.
  * Input field is cleared after adding a todo (`setTitle("")`).

* **Why use `nanoid`?**

  * Generates unique IDs to help React track each todo item.
  * Important for React's reconciliation (diffing) algorithm and to avoid key conflicts.

* **Controlled input**:

  * Helps keep React state as the single source of truth.
  * Allows easy validation, reset, or manipulation of input values.

---

## Read.jsx — Displaying and Deleting Todos (Read and Delete Operations)

```jsx
import "./Read.css";
import style from "./Read.module.css";

const Read = (props) => {
  const settodos = props.settodos;
  const todos = props.todos;

  const DeleteHandler = (id) => {
    // Filter out todo with the clicked id
    let filterTodo = todos.filter((todo) => {
      return todo.id != id;
    });

    // Update state with filtered todos
    settodos(filterTodo);
  };

  const renderTodos = todos.map((todo) => {
    return (
      <li key={todo.id} className="text-xl bg-gray-950 px-10 py-3 mb-2">
        <div className="flex justify-between font-light">
          {todo.title}{" "}
          <p
            onClick={() => DeleteHandler(todo.id)}
            className="cursor-pointer text-red-500"
          >
            Delete
          </p>
        </div>
      </li>
    );
  });

  return (
    <div className="w-[50%]  p-10 ml-5 overflow-hidden">
      <h1 className="mb-10 text-4xl text-white font-thin text-center">
        <span className="text-pink-600">Pending</span> Todos
      </h1>
      <ol>{renderTodos}</ol>
    </div>
  );
};

export default Read;
```

### Explanation:

* **Props `todos` and `settodos`**:

  * Read component uses the current list of todos to display.
  * Has access to `settodos` to update the list when a todo is deleted.

* **`DeleteHandler`**:

  * Called when user clicks "Delete".
  * Uses `.filter()` to create a new array without the clicked todo (`id`).
  * Calls `settodos` to update state in `App` — triggering UI update.

* **Rendering todos (`renderTodos`)**:

  * `.map()` converts the todos array into an array of `<li>` elements.
  * Each `<li>` has a `key` prop (todo.id) — important for React to track list items efficiently.
  * Displays todo title and a clickable "Delete" text.

* **Why use keys in list?**

  * Helps React identify which items changed, added, or removed.
  * Improves performance and prevents UI bugs.

* **Styling**:

  * Combines Tailwind classes and CSS modules.
  * CSS modules provide scoped styles to avoid conflicts.
  * Regular CSS imported too (`Read.css`).

---

# Summary of CRUD in This App

| Operation  | Where                  | How it works                                                                       |
| ---------- | ---------------------- | ---------------------------------------------------------------------------------- |
| **Create** | `Create.jsx`           | Form input controlled by state; on submit, adds new todo to array in parent state. |
| **Read**   | `Read.jsx`             | Maps todos to list items and displays them.                                        |
| **Update** | (Not implemented here) | You could add a toggle to mark complete or edit todo.                              |
| **Delete** | `Read.jsx`             | Filters out deleted todo and updates state.                                        |

---

# Additional Concepts

* **State Lifting**:
  `todos` state is stored in `App.jsx` (parent), but shared with child components `Create` and `Read` through props. This is called *lifting state up* — state lives in the common ancestor to share across children.

* **Immutability**:
  When updating the todos array, you don’t modify the original array directly. Instead, you create a *new* array (using spread `[...todos, newTodo]` or `.filter()`) and set that as new state. This is important for React to detect changes.

* **Component Reusability**:
  By splitting `Create` and `Read` into separate components, you keep code modular and easier to maintain or extend.

---