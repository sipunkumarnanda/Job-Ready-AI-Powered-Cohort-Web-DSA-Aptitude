# **Rest Parameters in JavaScript**  

## **What are Rest Parameters?**  
- **Rest parameters (`...`) allow a function to accept multiple arguments and store them in an array.**  
- It helps when we don't know how many arguments will be passed to the function.  
- The **rest parameter must be the last parameter** in the function definition.  

---

## **Example Code**  
```js
function abcd(a, b, ...args) {
    console.log(a, b, args);  
}

abcd(1, 2, 3, 4, 5);
```

### **Output:**  
```
1 2 [3, 4, 5]
```

---

## **Explanation:**  
1ï¸âƒ£ The function `abcd(a, b, ...args)` takes at least two arguments `a` and `b`.  
2ï¸âƒ£ **`...args` (rest parameter) collects all remaining arguments** into an array.  
3ï¸âƒ£ When calling `abcd(1, 2, 3, 4, 5)`:  
   - `a = 1`  
   - `b = 2`  
   - `args = [3, 4, 5]` (Rest of the arguments are stored in an array).  
4ï¸âƒ£ `console.log(a, b, args)` prints:  
   - `1` â†’ First parameter  
   - `2` â†’ Second parameter  
   - `[3, 4, 5]` â†’ Remaining values stored as an **array**.  

---

## **Key Points about Rest Parameters**  
âœ”ï¸ **Always the last parameter** in a function.  
âœ”ï¸ **Collects extra arguments into an array** for easy handling.  
âœ”ï¸ **Can be used in loops, array methods, and dynamic functions.**  

---

## **More Examples**  

### **1ï¸âƒ£ Sum of All Numbers Using Rest Parameters**  
```js
function sum(...nums) {
    return nums.reduce((acc, curr) => acc + curr, 0);
}

console.log(sum(1, 2, 3, 4, 5));  // Output: 15
```

### **2ï¸âƒ£ Filtering Even Numbers**  
```js
function evenNumbers(...numbers) {
    return numbers.filter(num => num % 2 === 0);
}

console.log(evenNumbers(1, 2, 3, 4, 5, 6));  // Output: [2, 4, 6]
```

---

### **Why Use Rest Parameters?**  
âœ… **More flexible functions** that can handle varying arguments.  
âœ… **Reduces the need for the `arguments` object** (older method).  
âœ… **Works with array methods** like `map()`, `filter()`, and `reduce()`.  

Rest parameters make JavaScript functions **powerful and reusable**. ğŸš€



---
---
---



# **Hoisting in JavaScript**  

## **What is Hoisting?**  
- **Hoisting is a JavaScript behavior where variable and function declarations are moved to the top of their scope before execution.**  
- This means you can **use a function or variable before declaring it** in the code.  
- **Only the declaration is hoisted, not the initialization (for variables).**  

---

## **Example 1: Hoisting with `var`**  
```js
console.log(a);  // undefined
var a = 12;
console.log(a);  // 12
```

### **How Does This Work?**  
- JavaScript **hoists** `var a;` to the top, but **does not hoist the value `12`.**  
- Internally, the code is interpreted like this:  

```js
var a;    // Hoisted declaration
console.log(a);  // undefined
a = 12;   // Value assigned later
console.log(a);  // 12
```

### **Key Takeaways:**  
âœ”ï¸ **Only the variable declaration (`var a;`) is hoisted.**  
âœ”ï¸ **The value (`a = 12;`) remains in its original place.**  
âœ”ï¸ **Accessing `a` before assignment gives `undefined`.**  

---

## **Example 2: Hoisting with Functions**  
```js
hoisting();  // Output: Hello

function hoisting() {
    console.log("Hello");
}
```

### **How Does This Work?**  
- Function **declarations** are fully hoisted, so you can call `hoisting()` before its actual definition.  
- Internally, JavaScript interprets it like this:  

```js
function hoisting() {   // Hoisted function
    console.log("Hello");
}

hoisting();  // Calls the function, works fine
```

### **Key Takeaways:**  
âœ”ï¸ **Functions are fully hoisted, including their body.**  
âœ”ï¸ **You can call a function before defining it in the code.**  

---

## **Hoisting with `let` and `const`**  
- `let` and `const` are **also hoisted**, but **they are not initialized** before their declaration.  
- This means **accessing them before declaration gives an error (`ReferenceError`).**  

```js
console.log(b);  // âŒ ReferenceError: Cannot access 'b' before initialization
let b = 10;
```

- This happens because **`let` and `const` variables are in the "temporal dead zone"** (TDZ) from the start of the block until their declaration.  

---

## **Difference Between `var`, `let`, and `const` in Hoisting**  

| Feature | `var` | `let` | `const` |
|---------|-------|-------|---------|
| **Hoisted?** | âœ… Yes | âœ… Yes | âœ… Yes |
| **Default Value Before Initialization?** | `undefined` | âŒ ReferenceError | âŒ ReferenceError |
| **Re-declaration Allowed?** | âœ… Yes | âŒ No | âŒ No |

---

## **Hoisting Summary**  
âœ”ï¸ **Variables (`var`) and functions are moved to the top before execution.**  
âœ”ï¸ **`var` variables are initialized as `undefined`.**  
âœ”ï¸ **`let` and `const` are hoisted but not initialized (TDZ issue).**  
âœ”ï¸ **Functions are fully hoisted and can be called before definition.**  

### **ğŸš€ Best Practices to Avoid Hoisting Issues:**  
âœ… Always declare variables **before using them**.  
âœ… Use `let` and `const` instead of `var` to prevent unexpected behavior.  
âœ… Declare functions **before calling them** for better readability.  

---

This was **Hoisting in JavaScript** in detail! ğŸš€ Let me know if you want more examples or clarifications. ğŸ˜Š



---
---
---



# **IIFE (Immediately Invoked Function Expression) in JavaScript**  

## **What is IIFE?**  
- **IIFE (Immediately Invoked Function Expression)** is a **self-executing function** that **runs immediately after it is defined** without requiring an explicit function call.  
- **Syntax:**  
  ```js
  (function () {
      console.log("Hello");
  })();
  ```
- **It is mainly used to avoid polluting the global scope.**  

---

## **1ï¸âƒ£ Simple IIFE Example**
```js
(function iife() {
    console.log("Hello World");
})();
```
### **Explanation:**  
âœ”ï¸ **This function executes immediately after being defined.**  
âœ”ï¸ **IIFE helps prevent unnecessary global variables.**  

---

## **2ï¸âƒ£ IIFE with Return Value**  
```js
var ans = (function iife2() {
    var a = 12;
    return a;
})();

console.log(ans);  // Output: 12
```
### **Explanation:**  
âœ”ï¸ **This IIFE returns a value (`a`) which is stored in the `ans` variable.**  
âœ”ï¸ **`a` remains private and is not accessible outside the function.**  

---

## **3ï¸âƒ£ IIFE with Private Variables**  
```js
var answer = (function abcd() {
    var a = 12;
    return {
        set: function (val) {
            a = val;
        },
        get: function () {
            console.log(a);
        }
    };
})();

console.log(answer);  // Output: { set: [Function: set], get: [Function: get] }
answer.set(69);
answer.get();  // Output: 69
```
### **Explanation:**  
âœ”ï¸ **This example demonstrates encapsulation, where the variable `a` is private.**  
âœ”ï¸ **Only `set` and `get` functions can modify and access `a`.**  

---

## **4ï¸âƒ£ IIFE for Creating a Library (Module Pattern)**  
```js
let sheryJS = (function sheryLibrary() {
    var lolo = 69; // Private variable

    return {
        imageEffect: function () {
            console.log("Image Effect");
        },
        mouseFollower: function () {
            console.log("Mouse Follower");
        }
    };
})();

sheryJS.imageEffect();   // Output: Image Effect
sheryJS.mouseFollower(); // Output: Mouse Follower
```
### **Explanation:**  
âœ”ï¸ **This is a modular approach where the `sheryJS` object contains functions.**  
âœ”ï¸ **The `lolo` variable is private and cannot be accessed outside.**  
âœ”ï¸ **This is an example of the JavaScript module pattern, which provides encapsulation.**  

---

## **ğŸ“ Summary**  
âœ”ï¸ **IIFE executes immediately after its definition.**  
âœ”ï¸ **It helps prevent global scope pollution.**  
âœ”ï¸ **Provides encapsulation by allowing private variables and functions.**  
âœ”ï¸ **Used in libraries and modules for better code organization.**  

---

These are **detailed IIFE notes**! ğŸš€ Let me know if you need more explanations or examples. ğŸ˜ƒ



---
---
---



# **Higher-Order Functions (HOFs) and Function Currying in JavaScript**  

## **What is a Higher-Order Function?**  
- A **Higher-Order Function (HOF)** is a function that **either returns another function or takes a function as an argument (or both).**  
- **HOFs are useful in functional programming, callbacks, closures, and function composition.**  

---

## **1ï¸âƒ£ Higher-Order Function Returning Another Function**  
### **Example:**  
```js
function hofs() {
    return function () {
        return function () {
            console.log("Hyehyehye");
        };
    };
}

hofs()()();  // Output: Hyehyehye
```
### **Explanation:**  
âœ”ï¸ **`hofs()` returns another function** â†’ So when we call `hofs()()()`, we are invoking all three nested functions.  
âœ”ï¸ **This is an example of a function returning another function multiple times.**  

---

## **2ï¸âƒ£ Higher-Order Function Accepting Another Function as a Parameter**  
### **Example:**  
```js
function hofs2(fnc) {
    fnc();
}

hofs2(function () {
    console.log("Hello HOFS");
});
```
### **Explanation:**  
âœ”ï¸ **`hofs2()` takes a function (`fnc`) as an argument and calls it inside.**  
âœ”ï¸ **This is useful for callbacks, event listeners, and function execution control.**  

---

## **3ï¸âƒ£ Function Currying**  
### **What is Function Currying?**  
- **Currying is a technique where a function is broken down into multiple smaller functions, each taking one argument at a time.**  
- **Instead of passing all arguments at once, it returns another function for the next argument.**  

### **Example:**  
```js
function funcA(val1) {
    return function (val2) {
        return function (val3) {
            console.log(val1 + val2 + val3);
        };
    };
}

funcA(1)(2)(3);  // Output: 6
```
### **Explanation:**  
âœ”ï¸ **`funcA(1)` returns another function that takes `val2` as an argument.**  
âœ”ï¸ **`funcA(1)(2)` returns another function that takes `val3`.**  
âœ”ï¸ **`funcA(1)(2)(3)` finally executes and returns `1 + 2 + 3 = 6`.**  
âœ”ï¸ **This makes functions reusable and allows partial application.**  

---

## **ğŸ“ Summary (Interview Ready Notes)**  
âœ”ï¸ **Higher-Order Function (HOF)** â†’ A function that **returns a function or takes a function as a parameter.**  
âœ”ï¸ **Returning Function Example** â†’ `hofs()()()` returns and executes multiple nested functions.  
âœ”ï¸ **Function Accepting Another Function** â†’ Useful in **callbacks, event handling, and functional programming.**  
âœ”ï¸ **Function Currying** â†’ Breaking down a function into multiple smaller functions, **taking one argument at a time.**  

**ğŸ›  HOFs and currying improve code reusability, modularity, and maintainability.** ğŸš€



---
---
---



# **Callback Functions in JavaScript**  

## **What is a Callback Function?**  
- A **callback function** is a function that is **passed as an argument** to another function and is executed later inside that function.  
- **It allows functions to be executed asynchronously or after a certain condition is met.**  

---

## **1ï¸âƒ£ Basic Example of a Callback Function**  
```js
function greet() {   // âœ… Normal function
    console.log("Good Morning.");
}

function cb(func) {  // âœ… Higher-order function (accepts a function as a parameter)
    func();  // âœ… Calls the function passed as an argument
}

cb(greet);  // âœ… Passing 'greet' as a callback
```
### **Explanation:**  
âœ”ï¸ `greet()` is a **normal function** that simply logs "Good Morning."  
âœ”ï¸ `cb()` is a **higher-order function** because it **takes another function (`func`) as a parameter.**  
âœ”ï¸ Inside `cb()`, we **call the function that was passed as an argument**, so `greet()` gets executed.  

---

## **2ï¸âƒ£ Callbacks with Parameters**  
```js
function greet(name) {
    console.log("Good Morning, " + name);
}

function cb(func, name) {
    func(name);  // âœ… Calls the function with an argument
}

cb(greet, "John");  // Output: Good Morning, John
```
âœ”ï¸ Here, we **pass both a function (`greet`) and a value (`"John"`) to the `cb` function.**  
âœ”ï¸ The function `cb()` calls `greet(name)`, so `"Good Morning, John"` is printed.  

---

## **3ï¸âƒ£ Callback Function in Asynchronous Operations**  
- **Callbacks are often used in asynchronous programming** (e.g., `setTimeout`, `fetch`, event listeners, etc.).  

### **Example with `setTimeout`:**  
```js
function showMessage() {
    console.log("This message appears after 2 seconds.");
}

setTimeout(showMessage, 2000);  // âœ… Executes 'showMessage' after 2 seconds
```
âœ”ï¸ `setTimeout()` **accepts a callback function** (`showMessage`) that runs after 2 seconds.  
âœ”ï¸ This is an **asynchronous operation** because it does not block the code execution.  

---

## **4ï¸âƒ£ Callbacks in Event Listeners**  
```js
document.getElementById("btn").addEventListener("click", function () {
    console.log("Button Clicked!");
});
```
âœ”ï¸ Here, we **pass an anonymous function as a callback** to `addEventListener()`.  
âœ”ï¸ This function **executes only when the button is clicked.**  

---

## **ğŸ“ Summary (Interview Ready Notes)**  
âœ”ï¸ **Callback Function** â†’ A function **passed as an argument** to another function and executed later.  
âœ”ï¸ **Higher-Order Function (HOF)** â†’ A function that **accepts another function as an argument** (e.g., `cb()` in the first example).  
âœ”ï¸ **Callbacks are useful for:**  
   - **Handling asynchronous operations** (like API calls, `setTimeout`, and `fetch`).  
   - **Event-driven programming** (like `addEventListener`).  
   - **Improving code modularity** by separating logic into smaller functions.  

**âœ¨ Callback functions are the foundation of JavaScriptâ€™s asynchronous behavior and event handling! ğŸš€**   



---
---
---



# **First-Class Functions in JavaScript**  

## **What is a First-Class Function?**  
- In JavaScript, **functions are treated as values**, which means:  
  âœ”ï¸ You can **assign functions to variables**.  
  âœ”ï¸ You can **pass functions as arguments** to other functions.  
  âœ”ï¸ You can **return functions from other functions**.  
- **This special behavior is called First-Class Functions.**  

---

## **1ï¸âƒ£ Assigning a Function to a Variable**  
Just like you assign a value to a variable, you can assign a function to a variable:  

```js
var a = () => console.log("Hello First-Class Function");
a();  // Output: Hello First-Class Function
```
âœ”ï¸ Here, `a` holds a function instead of a value.  
âœ”ï¸ Calling `a()` executes the function.  

---

## **2ï¸âƒ£ Passing a Function as an Argument**  
A function can be passed as an argument to another function.  

```js
function greet() {
    console.log("Good Morning!");
}

function executeFunction(func) {  // âœ… Higher-order function
    func();  // âœ… Calling the passed function
}

executeFunction(greet);  // Output: Good Morning!
```
âœ”ï¸ `greet()` is passed as an argument to `executeFunction()`.  
âœ”ï¸ Inside `executeFunction()`, the function is executed using `func()`.  

---

## **3ï¸âƒ£ Returning a Function from Another Function**  
A function can return another function.  

```js
function outerFunction() {
    return function () {
        console.log("Returned Function Executed!");
    };
}

let result = outerFunction();  // âœ… Returns a function
result();  // Output: Returned Function Executed!
```
âœ”ï¸ `outerFunction()` **returns an inner function.**  
âœ”ï¸ When we call `outerFunction()`, it returns the function **without executing it**.  
âœ”ï¸ `result()` then executes the returned function.  

---

## **4ï¸âƒ£ Functions Stored in Arrays & Objects**  
### **(a) Storing Functions in Arrays**  
```js
let arr = [
    () => console.log("Function 1"),
    () => console.log("Function 2")
];

arr[0]();  // Output: Function 1
arr[1]();  // Output: Function 2
```
âœ”ï¸ Functions can be stored in an **array** and accessed using their index.  

### **(b) Storing Functions in Objects**  
```js
let obj = {
    greet: () => console.log("Hello from Object Function")
};

obj.greet();  // Output: Hello from Object Function
```
âœ”ï¸ Functions can also be **stored as object properties** and called using dot notation.  

---

## **ğŸ“ Summary (Interview Ready Notes)**  
âœ”ï¸ **First-Class Function** â†’ A function in JavaScript is treated like a **value** and can be:  
   - **Assigned to variables**  
   - **Passed as arguments**  
   - **Returned from other functions**  
   - **Stored in arrays and objects**  
âœ”ï¸ **First-class functions enable JavaScript to support Higher-Order Functions (HOFs), making functional programming possible!** ğŸš€  



---
---
---



# **Pure Functions in JavaScript**  

## **What is a Pure Function?**  
A **pure function** is a function that:  
âœ”ï¸ **Always returns the same output for the same input.**  
âœ”ï¸ **Has no side effects (does not modify external variables, logs, or DOM).**  
âœ”ï¸ **Does not depend on or modify external state.**  

---

## **1ï¸âƒ£ Example of a Pure Function**  
```js
function add(a, b) {
    return a + b;  // âœ… No external modification
}

console.log(add(2, 3));  // Output: 5
console.log(add(2, 3));  // Output: 5
```
âœ”ï¸ **Same Input â†’ Same Output**  
âœ”ï¸ **No modification of external variables or state.**  

---

## **2ï¸âƒ£ Benefits of Pure Functions**  
ğŸ”¹ **Predictable & Easy to Test** â†’ Since output only depends on input.  
ğŸ”¹ **Better Performance** â†’ Since they donâ€™t modify global variables, they are easy to optimize.  
ğŸ”¹ **No Side Effects** â†’ They donâ€™t modify external values, making the code more maintainable.  

---

## **3ï¸âƒ£ Example of an Impure Function**  
An **impure function** modifies **external state**, making it unpredictable.  

```js
let total = 0;  // âŒ External variable

function addToTotal(a) {
    total += a;  // âŒ Modifying external state
}

addToTotal(10);
console.log(total);  // Output: 10

addToTotal(10);
console.log(total);  // Output: 20 (Different output for same input!)
```
âŒ This function is **impure** because:  
âœ”ï¸ It modifies a **global variable (`total`)**.  
âœ”ï¸ The same input (`10`) produces **different outputs** each time.  

---

## **ğŸ“ Summary (Interview-Ready Notes)**  
âœ”ï¸ **Pure Function** â†’ A function that **always gives the same output for the same input** and has **no side effects**.  
âœ”ï¸ **Impure Function** â†’ A function that **modifies external state or behaves unpredictably**.  
âœ”ï¸ **Pure functions help in better performance, testability, and functional programming.**  



---
---
---


# **Impure Functions in JavaScript**  

## **What is an Impure Function?**  
An **impure function** is a function that:  
âŒ **Modifies external (global) state**.  
âŒ **Does not always return the same output for the same input**.  
âŒ **Causes side effects like modifying variables, making API calls, or changing the DOM**.  

---

## **1ï¸âƒ£ Example of an Impure Function**  
```js
let total = 0;  // âŒ External variable

function addToTotal(a) {
    total += a;  // âŒ Modifies external variable
}

addToTotal(10);
console.log(total);  // Output: 10

addToTotal(10);
console.log(total);  // Output: 20 (Different output for same input!)
```
âŒ **Why is this function impure?**  
âœ”ï¸ It **modifies a global variable** (`total`).  
âœ”ï¸ The same input (`10`) does **not always return the same output**.  

---

## **2ï¸âƒ£ Another Example of an Impure Function**  
### **Modifying the DOM (Side Effect)**  
```js
function updateText() {
    document.getElementById("demo").innerText = "Changed!";  // âŒ Modifies the DOM
}

updateText();
```
âœ”ï¸ **This is impure** because it **changes the webpage content**, causing side effects.  

---

## **3ï¸âƒ£ How to Make It Pure?**  
âœ… **Do not modify external variables**.  
âœ… **Always return the same output for the same input**.  
```js
function add(a, b) {
    return a + b;  // âœ… No external modification
}

console.log(add(2, 3));  // Output: 5
console.log(add(2, 3));  // Output: 5
```
âœ”ï¸ **Pure functions** make the code **predictable, testable, and efficient**.  

---

## **ğŸ“ Summary (Interview-Ready Notes)**  
âœ”ï¸ **Impure Function** â†’ A function that **modifies external state or causes side effects**.  
âœ”ï¸ **Causes unpredictable behavior** because the output depends on external values.  
âœ”ï¸ **Examples of Impure Functions** â†’ Modifying global variables, changing the DOM, making API calls, or logging to the console.  
âœ”ï¸ **To make it pure** â†’ Avoid modifying external state and always return the same output for the same input.  



---
---
---



# **Scoping and Closures in JavaScript**  

## **1ï¸âƒ£ What is Scope?**  
**Scope** in JavaScript defines **where a variable can be accessed**.  
There are **three main types of scope**:  
âœ” **Global Scope**  
âœ” **Local (Function) Scope**  
âœ” **Block Scope (ES6 - `let` & `const`)**  

---

## **2ï¸âƒ£ Global Scope**  
- If a variable is **declared outside any function**, it belongs to the **global scope**.  
- **It can be accessed from anywhere in the code**.  

### âœ… **Example of Global Scope**  
```js
let value = 10;  // âœ… Global variable

function globalVar() {
    console.log(value);  // âœ… Accessing global variable inside a function
}

globalVar();  // Output: 10

console.log(value);  // âœ… Accessible outside the function
```
âœ” **Global variables should be used carefully** because they can be modified anywhere in the code, causing **unintended side effects**.  

---

## **3ï¸âƒ£ Local (Function) Scope**  
- **Variables declared inside a function** are **local** to that function.  
- They **cannot be accessed outside** the function.  

### âŒ **Example of Local Scope (Error)**  
```js
function x() {
    var y = 20;  // âœ… Local variable (only accessible inside 'x')
}

console.log(y);  // âŒ ReferenceError: y is not defined
```
âœ” **Why does this error occur?**  
Because `y` is declared inside `x()`, it is **not accessible outside** the function.  

---

## **4ï¸âƒ£ Block Scope (`let` & `const`)**  
- Introduced in **ES6**, variables declared using `let` and `const` are **block-scoped**.  
- They **only exist inside the `{}` block** in which they are declared.  

### âœ… **Example of Block Scope**  
```js
if (true) {
    let a = 30;
    const b = 40;
    console.log(a, b);  // âœ… Works inside the block
}

// console.log(a, b);  // âŒ ReferenceError: a is not defined
```
âœ” **Why is this error?**  
Because `a` and `b` are **only accessible inside** the `if` block.  

---

## **5ï¸âƒ£ Closures in JavaScript**  
### **What is a Closure?**  
A **closure** is when an **inner function "remembers" the variables** of its **outer function**, even **after the outer function has finished executing**.  

### âœ… **Example of Closure**  
```js
function outer() {
    let a = 20;  // âœ… Local variable inside 'outer()'

    return function inner() {  // âœ… Closure function
        console.log("The value of a is:", a);
    };
}

let returnFunc = outer();  // âœ… 'outer()' runs and returns 'inner'
returnFunc();  // Output: The value of a is: 20
```
âœ” **Why does this work?**  
Even though `outer()` has **finished execution**, the function `inner()` **still remembers** `a`. This is called a **closure**.  

---

## **ğŸ“ Summary (Interview-Ready Notes)**  
âœ” **Scope** â†’ Determines **where a variable can be accessed**.  
âœ” **Global Scope** â†’ Variables **declared outside any function** (accessible anywhere).  
âœ” **Local Scope** â†’ Variables **declared inside a function** (not accessible outside).  
âœ” **Block Scope (`let` & `const`)** â†’ Variables exist **only inside `{}`**.  
âœ” **Closures** â†’ When an **inner function remembers the variables** of an **outer function**, even after the outer function has executed.  

Closures **help in data privacy**, function currying, and maintaining state in JavaScript.  