# **Rest Parameters in JavaScript**  

## **What are Rest Parameters?**  
- **Rest parameters (`...`) allow a function to accept multiple arguments and store them in an array.**  
- It helps when we don't know how many arguments will be passed to the function.  
- The **rest parameter must be the last parameter** in the function definition.  

---

## **Example Code**  
```js
function abcd(a, b, ...args) {
    console.log(a, b, args);  
}

abcd(1, 2, 3, 4, 5);
```

### **Output:**  
```
1 2 [3, 4, 5]
```

---

## **Explanation:**  
1Ô∏è‚É£ The function `abcd(a, b, ...args)` takes at least two arguments `a` and `b`.  
2Ô∏è‚É£ **`...args` (rest parameter) collects all remaining arguments** into an array.  
3Ô∏è‚É£ When calling `abcd(1, 2, 3, 4, 5)`:  
   - `a = 1`  
   - `b = 2`  
   - `args = [3, 4, 5]` (Rest of the arguments are stored in an array).  
4Ô∏è‚É£ `console.log(a, b, args)` prints:  
   - `1` ‚Üí First parameter  
   - `2` ‚Üí Second parameter  
   - `[3, 4, 5]` ‚Üí Remaining values stored as an **array**.  

---

## **Key Points about Rest Parameters**  
‚úîÔ∏è **Always the last parameter** in a function.  
‚úîÔ∏è **Collects extra arguments into an array** for easy handling.  
‚úîÔ∏è **Can be used in loops, array methods, and dynamic functions.**  

---

## **More Examples**  

### **1Ô∏è‚É£ Sum of All Numbers Using Rest Parameters**  
```js
function sum(...nums) {
    return nums.reduce((acc, curr) => acc + curr, 0);
}

console.log(sum(1, 2, 3, 4, 5));  // Output: 15
```

### **2Ô∏è‚É£ Filtering Even Numbers**  
```js
function evenNumbers(...numbers) {
    return numbers.filter(num => num % 2 === 0);
}

console.log(evenNumbers(1, 2, 3, 4, 5, 6));  // Output: [2, 4, 6]
```

---

### **Why Use Rest Parameters?**  
‚úÖ **More flexible functions** that can handle varying arguments.  
‚úÖ **Reduces the need for the `arguments` object** (older method).  
‚úÖ **Works with array methods** like `map()`, `filter()`, and `reduce()`.  

Rest parameters make JavaScript functions **powerful and reusable**. üöÄ



---
---
---



# **Hoisting in JavaScript**  

## **What is Hoisting?**  
- **Hoisting is a JavaScript behavior where variable and function declarations are moved to the top of their scope before execution.**  
- This means you can **use a function or variable before declaring it** in the code.  
- **Only the declaration is hoisted, not the initialization (for variables).**  

---

## **Example 1: Hoisting with `var`**  
```js
console.log(a);  // undefined
var a = 12;
console.log(a);  // 12
```

### **How Does This Work?**  
- JavaScript **hoists** `var a;` to the top, but **does not hoist the value `12`.**  
- Internally, the code is interpreted like this:  

```js
var a;    // Hoisted declaration
console.log(a);  // undefined
a = 12;   // Value assigned later
console.log(a);  // 12
```

### **Key Takeaways:**  
‚úîÔ∏è **Only the variable declaration (`var a;`) is hoisted.**  
‚úîÔ∏è **The value (`a = 12;`) remains in its original place.**  
‚úîÔ∏è **Accessing `a` before assignment gives `undefined`.**  

---

## **Example 2: Hoisting with Functions**  
```js
hoisting();  // Output: Hello

function hoisting() {
    console.log("Hello");
}
```

### **How Does This Work?**  
- Function **declarations** are fully hoisted, so you can call `hoisting()` before its actual definition.  
- Internally, JavaScript interprets it like this:  

```js
function hoisting() {   // Hoisted function
    console.log("Hello");
}

hoisting();  // Calls the function, works fine
```

### **Key Takeaways:**  
‚úîÔ∏è **Functions are fully hoisted, including their body.**  
‚úîÔ∏è **You can call a function before defining it in the code.**  

---

## **Hoisting with `let` and `const`**  
- `let` and `const` are **also hoisted**, but **they are not initialized** before their declaration.  
- This means **accessing them before declaration gives an error (`ReferenceError`).**  

```js
console.log(b);  // ‚ùå ReferenceError: Cannot access 'b' before initialization
let b = 10;
```

- This happens because **`let` and `const` variables are in the "temporal dead zone"** (TDZ) from the start of the block until their declaration.  

---

## **Difference Between `var`, `let`, and `const` in Hoisting**  

| Feature | `var` | `let` | `const` |
|---------|-------|-------|---------|
| **Hoisted?** | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes |
| **Default Value Before Initialization?** | `undefined` | ‚ùå ReferenceError | ‚ùå ReferenceError |
| **Re-declaration Allowed?** | ‚úÖ Yes | ‚ùå No | ‚ùå No |

---

## **Hoisting Summary**  
‚úîÔ∏è **Variables (`var`) and functions are moved to the top before execution.**  
‚úîÔ∏è **`var` variables are initialized as `undefined`.**  
‚úîÔ∏è **`let` and `const` are hoisted but not initialized (TDZ issue).**  
‚úîÔ∏è **Functions are fully hoisted and can be called before definition.**  

### **üöÄ Best Practices to Avoid Hoisting Issues:**  
‚úÖ Always declare variables **before using them**.  
‚úÖ Use `let` and `const` instead of `var` to prevent unexpected behavior.  
‚úÖ Declare functions **before calling them** for better readability.  

---

This was **Hoisting in JavaScript** in detail! üöÄ Let me know if you want more examples or clarifications. üòä



---
---
---



# **IIFE (Immediately Invoked Function Expression) in JavaScript**  

## **What is IIFE?**  
- **IIFE (Immediately Invoked Function Expression)** is a **self-executing function** that **runs immediately after it is defined** without requiring an explicit function call.  
- **Syntax:**  
  ```js
  (function () {
      console.log("Hello");
  })();
  ```
- **It is mainly used to avoid polluting the global scope.**  

---

## **1Ô∏è‚É£ Simple IIFE Example**
```js
(function iife() {
    console.log("Hello World");
})();
```
### **Explanation:**  
‚úîÔ∏è **This function executes immediately after being defined.**  
‚úîÔ∏è **IIFE helps prevent unnecessary global variables.**  

---

## **2Ô∏è‚É£ IIFE with Return Value**  
```js
var ans = (function iife2() {
    var a = 12;
    return a;
})();

console.log(ans);  // Output: 12
```
### **Explanation:**  
‚úîÔ∏è **This IIFE returns a value (`a`) which is stored in the `ans` variable.**  
‚úîÔ∏è **`a` remains private and is not accessible outside the function.**  

---

## **3Ô∏è‚É£ IIFE with Private Variables**  
```js
var answer = (function abcd() {
    var a = 12;
    return {
        set: function (val) {
            a = val;
        },
        get: function () {
            console.log(a);
        }
    };
})();

console.log(answer);  // Output: { set: [Function: set], get: [Function: get] }
answer.set(69);
answer.get();  // Output: 69
```
### **Explanation:**  
‚úîÔ∏è **This example demonstrates encapsulation, where the variable `a` is private.**  
‚úîÔ∏è **Only `set` and `get` functions can modify and access `a`.**  

---

## **4Ô∏è‚É£ IIFE for Creating a Library (Module Pattern)**  
```js
let sheryJS = (function sheryLibrary() {
    var lolo = 69; // Private variable

    return {
        imageEffect: function () {
            console.log("Image Effect");
        },
        mouseFollower: function () {
            console.log("Mouse Follower");
        }
    };
})();

sheryJS.imageEffect();   // Output: Image Effect
sheryJS.mouseFollower(); // Output: Mouse Follower
```
### **Explanation:**  
‚úîÔ∏è **This is a modular approach where the `sheryJS` object contains functions.**  
‚úîÔ∏è **The `lolo` variable is private and cannot be accessed outside.**  
‚úîÔ∏è **This is an example of the JavaScript module pattern, which provides encapsulation.**  

---

## **üìù Summary**  
‚úîÔ∏è **IIFE executes immediately after its definition.**  
‚úîÔ∏è **It helps prevent global scope pollution.**  
‚úîÔ∏è **Provides encapsulation by allowing private variables and functions.**  
‚úîÔ∏è **Used in libraries and modules for better code organization.**  

---

These are **detailed IIFE notes**! üöÄ Let me know if you need more explanations or examples. üòÉ



---
---
---



# **Higher-Order Functions (HOFs) and Function Currying in JavaScript**  

## **What is a Higher-Order Function?**  
- A **Higher-Order Function (HOF)** is a function that **either returns another function or takes a function as an argument (or both).**  
- **HOFs are useful in functional programming, callbacks, closures, and function composition.**  

---

## **1Ô∏è‚É£ Higher-Order Function Returning Another Function**  
### **Example:**  
```js
function hofs() {
    return function () {
        return function () {
            console.log("Hyehyehye");
        };
    };
}

hofs()()();  // Output: Hyehyehye
```
### **Explanation:**  
‚úîÔ∏è **`hofs()` returns another function** ‚Üí So when we call `hofs()()()`, we are invoking all three nested functions.  
‚úîÔ∏è **This is an example of a function returning another function multiple times.**  

---

## **2Ô∏è‚É£ Higher-Order Function Accepting Another Function as a Parameter**  
### **Example:**  
```js
function hofs2(fnc) {
    fnc();
}

hofs2(function () {
    console.log("Hello HOFS");
});
```
### **Explanation:**  
‚úîÔ∏è **`hofs2()` takes a function (`fnc`) as an argument and calls it inside.**  
‚úîÔ∏è **This is useful for callbacks, event listeners, and function execution control.**  

---

## **3Ô∏è‚É£ Function Currying**  
### **What is Function Currying?**  
- **Currying is a technique where a function is broken down into multiple smaller functions, each taking one argument at a time.**  
- **Instead of passing all arguments at once, it returns another function for the next argument.**  

### **Example:**  
```js
function funcA(val1) {
    return function (val2) {
        return function (val3) {
            console.log(val1 + val2 + val3);
        };
    };
}

funcA(1)(2)(3);  // Output: 6
```
### **Explanation:**  
‚úîÔ∏è **`funcA(1)` returns another function that takes `val2` as an argument.**  
‚úîÔ∏è **`funcA(1)(2)` returns another function that takes `val3`.**  
‚úîÔ∏è **`funcA(1)(2)(3)` finally executes and returns `1 + 2 + 3 = 6`.**  
‚úîÔ∏è **This makes functions reusable and allows partial application.**  

---

## **üìù Summary (Interview Ready Notes)**  
‚úîÔ∏è **Higher-Order Function (HOF)** ‚Üí A function that **returns a function or takes a function as a parameter.**  
‚úîÔ∏è **Returning Function Example** ‚Üí `hofs()()()` returns and executes multiple nested functions.  
‚úîÔ∏è **Function Accepting Another Function** ‚Üí Useful in **callbacks, event handling, and functional programming.**  
‚úîÔ∏è **Function Currying** ‚Üí Breaking down a function into multiple smaller functions, **taking one argument at a time.**  

**üõ† HOFs and currying improve code reusability, modularity, and maintainability.** üöÄ



---
---
---



# **Callback Functions in JavaScript**  

## **What is a Callback Function?**  
- A **callback function** is a function that is **passed as an argument** to another function and is executed later inside that function.  
- **It allows functions to be executed asynchronously or after a certain condition is met.**  

---

## **1Ô∏è‚É£ Basic Example of a Callback Function**  
```js
function greet() {   // ‚úÖ Normal function
    console.log("Good Morning.");
}

function cb(func) {  // ‚úÖ Higher-order function (accepts a function as a parameter)
    func();  // ‚úÖ Calls the function passed as an argument
}

cb(greet);  // ‚úÖ Passing 'greet' as a callback
```
### **Explanation:**  
‚úîÔ∏è `greet()` is a **normal function** that simply logs "Good Morning."  
‚úîÔ∏è `cb()` is a **higher-order function** because it **takes another function (`func`) as a parameter.**  
‚úîÔ∏è Inside `cb()`, we **call the function that was passed as an argument**, so `greet()` gets executed.  

---

## **2Ô∏è‚É£ Callbacks with Parameters**  
```js
function greet(name) {
    console.log("Good Morning, " + name);
}

function cb(func, name) {
    func(name);  // ‚úÖ Calls the function with an argument
}

cb(greet, "John");  // Output: Good Morning, John
```
‚úîÔ∏è Here, we **pass both a function (`greet`) and a value (`"John"`) to the `cb` function.**  
‚úîÔ∏è The function `cb()` calls `greet(name)`, so `"Good Morning, John"` is printed.  

---

## **3Ô∏è‚É£ Callback Function in Asynchronous Operations**  
- **Callbacks are often used in asynchronous programming** (e.g., `setTimeout`, `fetch`, event listeners, etc.).  

### **Example with `setTimeout`:**  
```js
function showMessage() {
    console.log("This message appears after 2 seconds.");
}

setTimeout(showMessage, 2000);  // ‚úÖ Executes 'showMessage' after 2 seconds
```
‚úîÔ∏è `setTimeout()` **accepts a callback function** (`showMessage`) that runs after 2 seconds.  
‚úîÔ∏è This is an **asynchronous operation** because it does not block the code execution.  

---

## **4Ô∏è‚É£ Callbacks in Event Listeners**  
```js
document.getElementById("btn").addEventListener("click", function () {
    console.log("Button Clicked!");
});
```
‚úîÔ∏è Here, we **pass an anonymous function as a callback** to `addEventListener()`.  
‚úîÔ∏è This function **executes only when the button is clicked.**  

---

## **üìù Summary (Interview Ready Notes)**  
‚úîÔ∏è **Callback Function** ‚Üí A function **passed as an argument** to another function and executed later.  
‚úîÔ∏è **Higher-Order Function (HOF)** ‚Üí A function that **accepts another function as an argument** (e.g., `cb()` in the first example).  
‚úîÔ∏è **Callbacks are useful for:**  
   - **Handling asynchronous operations** (like API calls, `setTimeout`, and `fetch`).  
   - **Event-driven programming** (like `addEventListener`).  
   - **Improving code modularity** by separating logic into smaller functions.  

**‚ú® Callback functions are the foundation of JavaScript‚Äôs asynchronous behavior and event handling! üöÄ**   



---
---
---



# **First-Class Functions in JavaScript**  

## **What is a First-Class Function?**  
- In JavaScript, **functions are treated as values**, which means:  
  ‚úîÔ∏è You can **assign functions to variables**.  
  ‚úîÔ∏è You can **pass functions as arguments** to other functions.  
  ‚úîÔ∏è You can **return functions from other functions**.  
- **This special behavior is called First-Class Functions.**  

---

## **1Ô∏è‚É£ Assigning a Function to a Variable**  
Just like you assign a value to a variable, you can assign a function to a variable:  

```js
var a = () => console.log("Hello First-Class Function");
a();  // Output: Hello First-Class Function
```
‚úîÔ∏è Here, `a` holds a function instead of a value.  
‚úîÔ∏è Calling `a()` executes the function.  

---

## **2Ô∏è‚É£ Passing a Function as an Argument**  
A function can be passed as an argument to another function.  

```js
function greet() {
    console.log("Good Morning!");
}

function executeFunction(func) {  // ‚úÖ Higher-order function
    func();  // ‚úÖ Calling the passed function
}

executeFunction(greet);  // Output: Good Morning!
```
‚úîÔ∏è `greet()` is passed as an argument to `executeFunction()`.  
‚úîÔ∏è Inside `executeFunction()`, the function is executed using `func()`.  

---

## **3Ô∏è‚É£ Returning a Function from Another Function**  
A function can return another function.  

```js
function outerFunction() {
    return function () {
        console.log("Returned Function Executed!");
    };
}

let result = outerFunction();  // ‚úÖ Returns a function
result();  // Output: Returned Function Executed!
```
‚úîÔ∏è `outerFunction()` **returns an inner function.**  
‚úîÔ∏è When we call `outerFunction()`, it returns the function **without executing it**.  
‚úîÔ∏è `result()` then executes the returned function.  

---

## **4Ô∏è‚É£ Functions Stored in Arrays & Objects**  
### **(a) Storing Functions in Arrays**  
```js
let arr = [
    () => console.log("Function 1"),
    () => console.log("Function 2")
];

arr[0]();  // Output: Function 1
arr[1]();  // Output: Function 2
```
‚úîÔ∏è Functions can be stored in an **array** and accessed using their index.  

### **(b) Storing Functions in Objects**  
```js
let obj = {
    greet: () => console.log("Hello from Object Function")
};

obj.greet();  // Output: Hello from Object Function
```
‚úîÔ∏è Functions can also be **stored as object properties** and called using dot notation.  

---

## **üìù Summary (Interview Ready Notes)**  
‚úîÔ∏è **First-Class Function** ‚Üí A function in JavaScript is treated like a **value** and can be:  
   - **Assigned to variables**  
   - **Passed as arguments**  
   - **Returned from other functions**  
   - **Stored in arrays and objects**  
‚úîÔ∏è **First-class functions enable JavaScript to support Higher-Order Functions (HOFs), making functional programming possible!** üöÄ  



---
---
---



# **Pure Functions in JavaScript**  

## **What is a Pure Function?**  
A **pure function** is a function that:  
‚úîÔ∏è **Always returns the same output for the same input.**  
‚úîÔ∏è **Has no side effects (does not modify external variables, logs, or DOM).**  
‚úîÔ∏è **Does not depend on or modify external state.**  

---

## **1Ô∏è‚É£ Example of a Pure Function**  
```js
function add(a, b) {
    return a + b;  // ‚úÖ No external modification
}

console.log(add(2, 3));  // Output: 5
console.log(add(2, 3));  // Output: 5
```
‚úîÔ∏è **Same Input ‚Üí Same Output**  
‚úîÔ∏è **No modification of external variables or state.**  

---

## **2Ô∏è‚É£ Benefits of Pure Functions**  
üîπ **Predictable & Easy to Test** ‚Üí Since output only depends on input.  
üîπ **Better Performance** ‚Üí Since they don‚Äôt modify global variables, they are easy to optimize.  
üîπ **No Side Effects** ‚Üí They don‚Äôt modify external values, making the code more maintainable.  

---

## **3Ô∏è‚É£ Example of an Impure Function**  
An **impure function** modifies **external state**, making it unpredictable.  

```js
let total = 0;  // ‚ùå External variable

function addToTotal(a) {
    total += a;  // ‚ùå Modifying external state
}

addToTotal(10);
console.log(total);  // Output: 10

addToTotal(10);
console.log(total);  // Output: 20 (Different output for same input!)
```
‚ùå This function is **impure** because:  
‚úîÔ∏è It modifies a **global variable (`total`)**.  
‚úîÔ∏è The same input (`10`) produces **different outputs** each time.  

---

## **üìù Summary (Interview-Ready Notes)**  
‚úîÔ∏è **Pure Function** ‚Üí A function that **always gives the same output for the same input** and has **no side effects**.  
‚úîÔ∏è **Impure Function** ‚Üí A function that **modifies external state or behaves unpredictably**.  
‚úîÔ∏è **Pure functions help in better performance, testability, and functional programming.**  



---
---
---


# **Impure Functions in JavaScript**  

## **What is an Impure Function?**  
An **impure function** is a function that:  
‚ùå **Modifies external (global) state**.  
‚ùå **Does not always return the same output for the same input**.  
‚ùå **Causes side effects like modifying variables, making API calls, or changing the DOM**.  

---

## **1Ô∏è‚É£ Example of an Impure Function**  
```js
let total = 0;  // ‚ùå External variable

function addToTotal(a) {
    total += a;  // ‚ùå Modifies external variable
}

addToTotal(10);
console.log(total);  // Output: 10

addToTotal(10);
console.log(total);  // Output: 20 (Different output for same input!)
```
‚ùå **Why is this function impure?**  
‚úîÔ∏è It **modifies a global variable** (`total`).  
‚úîÔ∏è The same input (`10`) does **not always return the same output**.  

---

## **2Ô∏è‚É£ Another Example of an Impure Function**  
### **Modifying the DOM (Side Effect)**  
```js
function updateText() {
    document.getElementById("demo").innerText = "Changed!";  // ‚ùå Modifies the DOM
}

updateText();
```
‚úîÔ∏è **This is impure** because it **changes the webpage content**, causing side effects.  

---

## **3Ô∏è‚É£ How to Make It Pure?**  
‚úÖ **Do not modify external variables**.  
‚úÖ **Always return the same output for the same input**.  
```js
function add(a, b) {
    return a + b;  // ‚úÖ No external modification
}

console.log(add(2, 3));  // Output: 5
console.log(add(2, 3));  // Output: 5
```
‚úîÔ∏è **Pure functions** make the code **predictable, testable, and efficient**.  

---

## **üìù Summary (Interview-Ready Notes)**  
‚úîÔ∏è **Impure Function** ‚Üí A function that **modifies external state or causes side effects**.  
‚úîÔ∏è **Causes unpredictable behavior** because the output depends on external values.  
‚úîÔ∏è **Examples of Impure Functions** ‚Üí Modifying global variables, changing the DOM, making API calls, or logging to the console.  
‚úîÔ∏è **To make it pure** ‚Üí Avoid modifying external state and always return the same output for the same input.  



---
---
---



# **Scoping and Closures in JavaScript**  

## **1Ô∏è‚É£ What is Scope?**  
**Scope** in JavaScript defines **where a variable can be accessed**.  
There are **three main types of scope**:  
‚úî **Global Scope**  
‚úî **Local (Function) Scope**  
‚úî **Block Scope (ES6 - `let` & `const`)**  

---

## **2Ô∏è‚É£ Global Scope**  
- If a variable is **declared outside any function**, it belongs to the **global scope**.  
- **It can be accessed from anywhere in the code**.  

### ‚úÖ **Example of Global Scope**  
```js
let value = 10;  // ‚úÖ Global variable

function globalVar() {
    console.log(value);  // ‚úÖ Accessing global variable inside a function
}

globalVar();  // Output: 10

console.log(value);  // ‚úÖ Accessible outside the function
```
‚úî **Global variables should be used carefully** because they can be modified anywhere in the code, causing **unintended side effects**.  

---

## **3Ô∏è‚É£ Local (Function) Scope**  
- **Variables declared inside a function** are **local** to that function.  
- They **cannot be accessed outside** the function.  

### ‚ùå **Example of Local Scope (Error)**  
```js
function x() {
    var y = 20;  // ‚úÖ Local variable (only accessible inside 'x')
}

console.log(y);  // ‚ùå ReferenceError: y is not defined
```
‚úî **Why does this error occur?**  
Because `y` is declared inside `x()`, it is **not accessible outside** the function.  

---

## **4Ô∏è‚É£ Block Scope (`let` & `const`)**  
- Introduced in **ES6**, variables declared using `let` and `const` are **block-scoped**.  
- They **only exist inside the `{}` block** in which they are declared.  

### ‚úÖ **Example of Block Scope**  
```js
if (true) {
    let a = 30;
    const b = 40;
    console.log(a, b);  // ‚úÖ Works inside the block
}

// console.log(a, b);  // ‚ùå ReferenceError: a is not defined
```
‚úî **Why is this error?**  
Because `a` and `b` are **only accessible inside** the `if` block.  

---

## **5Ô∏è‚É£ Closures in JavaScript**  
### **What is a Closure?**  
A **closure** is when an **inner function "remembers" the variables** of its **outer function**, even **after the outer function has finished executing**.  

### ‚úÖ **Example of Closure**  
```js
function outer() {
    let a = 20;  // ‚úÖ Local variable inside 'outer()'

    return function inner() {  // ‚úÖ Closure function
        console.log("The value of a is:", a);
    };
}

let returnFunc = outer();  // ‚úÖ 'outer()' runs and returns 'inner'
returnFunc();  // Output: The value of a is: 20
```
‚úî **Why does this work?**  
Even though `outer()` has **finished execution**, the function `inner()` **still remembers** `a`. This is called a **closure**.  

---

## **üìù Summary (Interview-Ready Notes)**  
‚úî **Scope** ‚Üí Determines **where a variable can be accessed**.  
‚úî **Global Scope** ‚Üí Variables **declared outside any function** (accessible anywhere).  
‚úî **Local Scope** ‚Üí Variables **declared inside a function** (not accessible outside).  
‚úî **Block Scope (`let` & `const`)** ‚Üí Variables exist **only inside `{}`**.  
‚úî **Closures** ‚Üí When an **inner function remembers the variables** of an **outer function**, even after the outer function has executed.  

Closures **help in data privacy**, function currying, and maintaining state in JavaScript.  