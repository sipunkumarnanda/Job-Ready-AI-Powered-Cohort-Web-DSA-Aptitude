## **Scoping & Closures in JavaScript**  

### **1Ô∏è‚É£ What is Scope in JavaScript?**  
Scope in JavaScript refers to the **accessibility and lifetime** of variables, functions, and objects in the code. It determines **where a variable can be used** and whether it is **accessible** inside a particular part of the code.  

There are **three main types of scope** in JavaScript:  
1. **Global Scope**  
2. **Function Scope (Local Scope)**  
3. **Block Scope (ES6 introduced `let` & `const`)**  

---

### **üîπ Global Scope**  
A variable declared **outside of any function or block** is available **everywhere** in the script.  

**Example:**  
```javascript
let globalVar = "I am global";  

function showGlobal() {
    console.log(globalVar); // ‚úÖ Accessible inside function
}

showGlobal();
console.log(globalVar); // ‚úÖ Accessible outside function
```
üîπ **Global variables are accessible everywhere**, but using too many global variables can cause conflicts.  

---

### **üîπ Function Scope (Local Scope)**  
A variable declared **inside a function** is only available **within that function** and cannot be accessed from outside.  

**Example:**  
```javascript
function localScopeExample() {
    let localVar = "I am local";  
    console.log(localVar); // ‚úÖ Accessible inside function
}

localScopeExample();
console.log(localVar); // ‚ùå Uncaught ReferenceError: localVar is not defined
```
üîπ **Function-scoped variables cannot be accessed outside the function.**  

---

### **üîπ Block Scope (`let` & `const`)**  
Before ES6, JavaScript had only **global and function scope**. The introduction of `let` and `const` brought **block scope**, meaning a variable is accessible **only within the block `{}` where it was defined**.  

**Example:**  
```javascript
{
    let blockScopedVar = "I exist only in this block";
    console.log(blockScopedVar); // ‚úÖ Accessible inside the block
}

console.log(blockScopedVar); // ‚ùå ReferenceError: blockScopedVar is not defined
```
üîπ `let` and `const` are **block-scoped**, while `var` is **function-scoped**.  

---

## **2Ô∏è‚É£ What is a Closure in JavaScript?**  
A **closure** is a function that **remembers the variables from its outer scope**, even after the outer function has finished executing.  

Closures **allow functions to access variables from their parent scope**, even if the parent function is no longer active.  

---

### **üîπ Example of Closure**  
```javascript
function outerFunction() {
    let outerVar = "I am from outer function";

    function innerFunction() {
        console.log(outerVar); // ‚úÖ Can access outerVar even after outerFunction is executed
    }

    return innerFunction;
}

const closureFunc = outerFunction();  
closureFunc(); // Output: "I am from outer function"
```
üîπ **Here‚Äôs what happens:**  
1. `outerFunction()` is called and returns `innerFunction`.  
2. `closureFunc` now holds `innerFunction`.  
3. When we call `closureFunc()`, it still **remembers** `outerVar` from `outerFunction`, even though `outerFunction` has already finished execution.  

---

### **üîπ Real-World Example of Closures**  
Closures are commonly used in **data privacy** and **function factories**.  

**Example: Counter Function using Closure**  
```javascript
function createCounter() {
    let count = 0; // Private variable

    return function() {
        count++;
        console.log("Current count:", count);
    };
}

const counter = createCounter();  
counter(); // Output: Current count: 1
counter(); // Output: Current count: 2
counter(); // Output: Current count: 3
```
üîπ **Why does this work?**  
- `count` is a **private variable** inside `createCounter()`.  
- The inner function **remembers `count` even after `createCounter()` has finished execution**.  
- Each time `counter()` is called, it **increments the value of `count`**, preserving state between function calls.  

---

## **3Ô∏è‚É£ Summary: Scoping vs. Closures**  
| Concept  | Definition | Example |
|----------|-----------|---------|
| **Scope** | Determines where a variable is accessible in the code. | Global, Function, Block Scope |
| **Closure** | A function that remembers the variables of its parent scope even after execution. | Function returning another function |

‚úÖ **Closures allow data privacy** (like private variables).  
‚úÖ **Closures keep variables alive** even after a function finishes executing.  
‚úÖ **Understanding scope helps in debugging** and writing efficient code. 