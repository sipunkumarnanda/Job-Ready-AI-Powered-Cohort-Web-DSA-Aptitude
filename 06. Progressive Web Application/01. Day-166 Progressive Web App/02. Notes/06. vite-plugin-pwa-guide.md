
# Using `vite-plugin-pwa` — in-depth guide (how to add a PWA to a Vite app)

### Reference - https://www.npmjs.com/package/vite-plugin-pwa


Great — `vite-plugin-pwa` is the usual, well-supported way to add manifest + service worker generation to any Vite app (React/Vue/Svelte/vanilla). Below I’ll walk you through **what it does**, **install + config patterns**, **examples** (simple → advanced), **how to register the SW in the client**, **dev vs production**, and common pitfalls & testing. I’ll also include ready-to-drop code examples.

**Short summary:** `vite-plugin-pwa` auto-generates (or injects into) a service worker and manifest, and exposes tiny runtime helpers (virtual modules) so your app can react to updates. It uses Workbox under the hood for `generateSW` and supports an `injectManifest` mode when you need a custom SW. ([vite-pwa-org.netlify.app][1])

---

## 1) Install & quick start

Install dev dependency:

```bash
# npm
npm install -D vite-plugin-pwa

# or pnpm
pnpm add -D vite-plugin-pwa
```

Then add to your `vite.config.*`:

```js
// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'   // or vue/svelte/etc
import { VitePWA } from 'vite-plugin-pwa'

export default defineConfig({
  plugins: [
    react(),
    VitePWA() // default zero-config
  ]
})
```

This basic step is the official recommended entry point. ([npm][2])

---

## 2) Two main modes (strategies): `generateSW` vs `injectManifest`

* **`generateSW` (default / simple):** the plugin uses Workbox to automatically generate a service worker that precaches your build assets and applies runtime caching strategies you configure. Good for most apps.
* **`injectManifest` (advanced):** you author a custom service worker (e.g., `src/sw.js/ts`) and the plugin builds it with Vite and injects the auto-generated precache manifest (`self.__WB_MANIFEST`). Use this when you need custom push/logic or special lifecycle control. ([vite-pwa-org.netlify.app][3])

---

## 3) Typical `vite.config.ts` — **simple (generateSW)** example

```ts
// vite.config.ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { VitePWA } from 'vite-plugin-pwa'

export default defineConfig({
  plugins: [
    react(),
    VitePWA({
      registerType: 'autoUpdate', // 'autoUpdate' | 'prompt' | null
      includeAssets: ['favicon.svg', 'robots.txt', 'apple-touch-icon.png'],
      manifest: {
        name: 'My App',
        short_name: 'App',
        start_url: '/',
        display: 'standalone',
        background_color: '#ffffff',
        theme_color: '#0d6efd',
        icons: [
          { src: '/icons/icon-192.png', sizes: '192x192', type: 'image/png' },
          { src: '/icons/icon-512.png', sizes: '512x512', type: 'image/png', purpose: 'any maskable' }
        ]
      },
      workbox: {
        // runtimeCaching syntax uses Workbox options
        runtimeCaching: [
          {
            urlPattern: /^https:\/\/your-cdn\.example\/.*\.(?:png|jpg|jpeg|svg)$/,
            handler: 'CacheFirst',
            options: {
              cacheName: 'cdn-images',
              expiration: { maxEntries: 60, maxAgeSeconds: 60 * 60 * 24 * 30 }
            }
          },
          {
            urlPattern: /^https:\/\/api\.example\.com\/.*$/,
            handler: 'NetworkFirst',
            options: { cacheName: 'api-cache', networkTimeoutSeconds: 10 }
          }
        ]
      }
    })
  ]
})
```

**Notes:**

* `registerType` controls how updates are applied (auto-reload vs prompting the user). See update handling below. ([vite-pwa-org.netlify.app][4])
* `manifest` will be emitted automatically (manifest.webmanifest).
* `workbox.runtimeCaching` entries translate to Workbox runtime rules for caching APIs, images, etc. (tweak to your needs). ([npm][5])

---

## 4) Advanced: `injectManifest` (custom SW)

If you need full control (push, background sync, custom routing), use `injectManifest`. Create your own SW and let the plugin inject the precache list.

`/src/custom-sw.js`:

```js
// custom-sw.js
import { precacheAndRoute } from 'workbox-precaching'
// __WB_MANIFEST will be injected by the plugin
precacheAndRoute(self.__WB_MANIFEST)

// add custom fetch, push, sync handlers
self.addEventListener('fetch', (e) => {
  // custom handling...
})
```

`vite.config.ts`:

```ts
VitePWA({
  strategies: 'injectManifest',
  srcDir: 'src',          // where your custom sw lives
  filename: 'custom-sw.js',
  injectManifest: {
    globPatterns: ['**/*.{js,css,html,ico,png,svg}']
  },
  manifest: { /* ... */ }
})
```

**Caveats:**

* Since `v0.15.0`, the plugin builds your custom SW with Vite (so Vite plugins may affect the SW build). If you use Vite plugins inside the SW build, you may need to add them to `injectManifest.plugins`. Read the docs & issues if you hit strange builds. ([vite-pwa-org.netlify.app][3])

---

## 5) Register the service worker in your app (client)

The plugin exposes a **virtual module** `virtual:pwa-register` (and framework-specific ones like `virtual:pwa-register/react` or `/vue`) to simplify registration and update handling.

Vanilla / plain import:

```ts
import { registerSW } from 'virtual:pwa-register'

const updateSW = registerSW({
  onNeedRefresh() { /* show a "New version available" prompt */ },
  onOfflineReady() { /* show "App ready to work offline" */ }
})
```

React hook (recommended pattern — example):

```tsx
// src/hooks/usePwa.tsx
import { useRegisterSW } from 'virtual:pwa-register/react'

export default function UsePwa() {
  const { offlineReady, needRefresh, updateServiceWorker } = useRegisterSW()
  // show UI based on offlineReady / needRefresh
}
```

**Important:** you must import these virtual modules in the app for the SW to register when using some `registerType` modes. The plugin docs explain which registerType requires you to import the virtual modules (e.g., `autoUpdate` and `prompt` behavior). ([vite-pwa-org.netlify.app][6])

---

## 6) Update lifecycle & UX: `registerType` and user prompts

* `registerType: 'autoUpdate'` → plugin tries to update and activate automatically (may reload pages). Use carefully — it can cause data loss if user is mid-form. ([vite-pwa-org.netlify.app][4])
* `registerType: 'prompt'` → plugin informs the app when a new SW is waiting (`onNeedRefresh`), and you decide when to call the `updateSW()`/`updateServiceWorker()` function (show "Refresh" prompt). This is often better UX. ([vite-pwa-org.netlify.app][7])

---

## 7) Dev vs Production: why you might not see the SW in `vite dev`

The plugin **does not generate the production service worker during dev mode** by default. To test SW behavior locally you typically do:

```bash
npm run build
npm run preview      # or use a static server to serve the built files
# plugin only produces the manifest & service worker on build
```

(So build+preview is the common pattern for local testing.) ([npm][2])

---

## 8) Assets, manifest icons, and path gotchas

* Static PWA icons referenced in `manifest.icons` are usually expected to live in your `public` folder (so their final URLs are stable). If you use Vite’s hashed assets (imported from `src/assets`) you may run into wrong paths in the generated manifest — either put icons in `public` or handle them with Vite asset imports carefully. There are known issues/threads about manifest icon paths; using `public/` is simplest and reliable. ([GitHub][8])

---

## 9) Push, background sync, and advanced features

* For custom push handling, background sync, or other advanced SW APIs, **use `injectManifest`** and add your push/subscription logic inside your custom SW. The plugin will still inject the precache manifest into your SW. There are community Q\&A threads showing patterns to combine FCM / push with the plugin. ([Stack Overflow][9])

---

## 10) Testing & debugging checklist

* Build and `preview` your site; check **Application → Manifest** and **Application → Service Workers** in Chrome DevTools.
* Run Lighthouse PWA audit in DevTools (shows manifest + SW + icons + installability checks).
* Test “Add to Home screen” on Android Chrome. iOS Safari has limited PWA support (use apple meta tags separately).
* If SW is not updating as expected, check `registerType` and the runtime UI hooks (`onNeedRefresh`, `onOfflineReady`) and `console` for registration messages. ([vite-pwa-org.netlify.app][4])

---

## 11) Common pitfalls & troubleshooting tips

* **No SW in dev** → use `build` + `preview`. ([npm][2])
* **Virtual module TS error** (`Cannot find module 'virtual:pwa-register'`) → add plugin's `client.d.ts` to TypeScript `include` or install `workbox-window` as needed (some setups need explicit types). See GitHub issues for fixes. ([GitHub][10])
* **InjectManifest build issues** → if your custom SW uses plugins/transformations, remember the SW is built with Vite; you may need to configure `injectManifest.plugins`. ([vite-pwa-org.netlify.app][3])
* **Manifest icon path errors** → put icons in `public/` or ensure final paths are correct after Vite bundling. ([GitHub][8])

---

## 12) Minimal checklist to ship a PWA via Vite + `vite-plugin-pwa`

* [ ] Add `vite-plugin-pwa` to `vite.config.*` (choose `generateSW` or `injectManifest`). ([GitHub][11])
* [ ] Provide `manifest` (name, short\_name, icons, start\_url, display).
* [ ] Register SW in client with `virtual:pwa-register` (or use auto registration). ([vite-pwa-org.netlify.app][6])
* [ ] Build and `preview` for testing. ([npm][2])
* [ ] Run Lighthouse PWA audit; test "Add to home screen" on device.

---

## Useful references (official)

* Plugin home / docs (getting started, guide, examples). ([vite-pwa-org.netlify.app][1])
* GitHub (repo + examples). ([GitHub][11])
* NPM package page (install instructions + notes). ([npm][2])

---