
# ğŸŒ² Pinecone Notes â€” Beginner-Friendly, Step-by-Step (JavaScript + Gemini Edition)

## ğŸ§  What is Pinecone?

Pinecone is a **managed vector database**. It stores numerical representations of data (called **embeddings** or **vectors**) and lets you **search by meaning** rather than exact keywords. This powers things like:

* ğŸ” **Semantic search** (find similar texts/images/code)
* ğŸ§© **RAG** (Retrieval-Augmented Generation) for LLM apps
* ğŸ¯ **Recommendations & similarity** (nearest-neighbor lookup)
* ğŸ§¹ **Deduplication** and clustering

---

## ğŸ§© Key Concepts (mental model for devs)

* **Embedding / vector** â†’ list of floats (like `[0.1, 0.2, â€¦]`)
* **Dimension** â†’ size of that list (depends on embedding model, Gemini = `768`)
* **Metric** â†’ how Pinecone decides similarity (`cosine`, `dotproduct`, `euclidean`)
* **Index** â†’ your searchable collection of vectors
* **ID** â†’ unique identifier for a vector (like `doc-1`)
* **Metadata** â†’ JSON object stored with the vector (tags, source, etc.)
* **Filter** â†’ search with conditions on metadata
* **Namespace** â†’ optional sub-collections inside an index

---

## ğŸ§° Requirements

* ğŸ” Pinecone account + API key
* ğŸ§ª **Gemini embedding model** (`text-embedding-004`)
* ğŸ§® Know the embedding **dimension** (Gemini = `768`)
* ğŸ§­ Decide **metric** (`cosine` is safe default for text)

---

## ğŸš¦ Quick Start: End-to-End in JavaScript (with Gemini)

### 1) Install SDKs ğŸ§±

```bash
npm install @pinecone-database/pinecone @google/generative-ai
```

### 2) Setup API Keys ğŸ”‘

In a `.env` file:

```env
PINECONE_API_KEY=your-pinecone-key
GOOGLE_API_KEY=your-gemini-key
```

### 3) Get embeddings ğŸ§¬ (Gemini)

```js
import { GoogleGenerativeAI } from "@google/generative-ai";

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY);

async function embedText(text) {
  const model = genAI.getGenerativeModel({ model: "text-embedding-004" });
  const res = await model.embedContent(text);
  return res.embedding.values; // array of floats
}

// Example
const vector = await embedText("Pinecone is a vector database.");
console.log("Vector length:", vector.length); // 768
```

> âœ… Note: Geminiâ€™s **`text-embedding-004`** produces **768-dim vectors**.

---

### 4) Create a Pinecone Index ğŸ“¦

```js
import { Pinecone } from "@pinecone-database/pinecone";

const pc = new Pinecone({ apiKey: process.env.PINECONE_API_KEY });

const indexName = "gemini-index";
const dimension = 768;  // match Gemini
const metric = "cosine";

// create index if not exists
const existing = await pc.listIndexes();
if (!existing.indexes.find(i => i.name === indexName)) {
  await pc.createIndex({
    name: indexName,
    dimension,
    metric,
    spec: { serverless: { cloud: "aws", region: "us-west-2" } }
  });
}

const index = pc.index(indexName);
```

---

### 5) Upsert (insert) vectors ğŸ“¤

```js
const docs = [
  { id: "doc-1", text: "What is Pinecone? Pinecone is a vector DB...", source: "guide" },
  { id: "doc-2", text: "RAG improves LLM factuality by retrieving context...", source: "blog" }
];

const vectors = [];
for (const doc of docs) {
  const emb = await embedText(doc.text); // Gemini embedding
  vectors.push({
    id: doc.id,
    values: emb,
    metadata: { text: doc.text, source: doc.source }
  });
}

await index.upsert(vectors);
```

---

### 6) Query by meaning ğŸ”

```js
const query = "Explain RAG for chatbots";
const qEmb = await embedText(query);

const result = await index.query({
  vector: qEmb,
  topK: 5,
  includeMetadata: true,
  filter: { source: { $eq: "blog" } }
});

for (const match of result.matches) {
  console.log(match.id, match.score.toFixed(3), match.metadata.text.slice(0, 80) + "â€¦");
}
```

---

### 7) Fetch / Update / Delete ğŸ§¹

```js
// fetch by ID
const fetched = await index.fetch(["doc-1"]);
console.log(fetched);

// update metadata
await index.update({
  id: "doc-1",
  setMetadata: { source: "guide-v2" }
});

// delete by ID
await index.deleteOne("doc-2");

// delete by filter
await index.deleteMany({ filter: { source: { $eq: "obsolete" } } });
```

---

### 8) Namespaces ğŸ—‚ï¸

```js
await index.upsert(vectors, { namespace: "tenant-a" });

const res = await index.query({
  vector: await embedText("chatbots"),
  topK: 3,
  includeMetadata: true,
  namespace: "tenant-a"
});
```

---

## ğŸ§  Minimal RAG Flow (Web Dev view)

1. ğŸ“¥ **Load docs** â†’ (e.g., from file system or CMS)
2. âœ‚ï¸ **Chunk** â†’ break text into 500â€“800 token chunks
3. ğŸ§¬ **Embed** â†’ call Gemini API â†’ get vectors
4. ğŸ“¦ **Upsert** â†’ store in Pinecone with metadata
5. ğŸ” **Query** â†’ embed user input with Gemini â†’ `index.query()`
6. ğŸ§µ **Context** â†’ insert retrieved chunks into LLM prompt

---

## ğŸ’¡ Pro Tips

* Always use Geminiâ€™s `text-embedding-004` â†’ **768-dim**
* Use **cosine** similarity in Pinecone
* Batch embeddings for performance
* Store useful metadata (`source`, `url`) for filtering
* Use stable IDs (like `file:page:chunk`)
* Start with `topK=5` and adjust

---

## ğŸ§¯ Common Pitfalls

* **Dimension mismatch** â†’ Pinecone must be `768` for Gemini
* **Index not ready** â†’ wait a few seconds after creation
* **Bad retrieval** â†’ must embed both docs + queries with Gemini
* **Filter issues** â†’ check metadata JSON shape

---

## ğŸ“œ JavaScript Cheat Sheet (Gemini Edition)

**Embed**

```js
const vector = await embedText("Hello world");
```

**Create index**

```js
await pc.createIndex({
  name: "idx",
  dimension: 768,
  metric: "cosine",
  spec: { serverless: { cloud: "aws", region: "us-west-2" } }
});
```

**Upsert**

```js
await index.upsert([
  { id: "a1", values: vector, metadata: { text: "hello", source: "notes" } }
]);
```

**Query**

```js
await index.query({ vector, topK: 5, includeMetadata: true });
```

**Fetch / Update / Delete**

```js
await index.fetch(["a1"]);
await index.update({ id: "a1", setMetadata: { source: "notes-v2" } });
await index.deleteOne("a1");
```

**Namespaces**

```js
await index.upsert(vectors, { namespace: "tenant-123" });
await index.query({ vector, topK: 5, namespace: "tenant-123" });
```

---