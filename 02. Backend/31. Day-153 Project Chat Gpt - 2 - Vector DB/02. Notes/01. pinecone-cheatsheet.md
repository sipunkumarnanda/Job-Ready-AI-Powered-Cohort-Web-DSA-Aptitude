
# 🌲 Pinecone Notes — Beginner-Friendly, Step-by-Step (JavaScript + Gemini Edition)

## 🧠 What is Pinecone?

Pinecone is a **managed vector database**. It stores numerical representations of data (called **embeddings** or **vectors**) and lets you **search by meaning** rather than exact keywords. This powers things like:

* 🔎 **Semantic search** (find similar texts/images/code)
* 🧩 **RAG** (Retrieval-Augmented Generation) for LLM apps
* 🎯 **Recommendations & similarity** (nearest-neighbor lookup)
* 🧹 **Deduplication** and clustering

---

## 🧩 Key Concepts (mental model for devs)

* **Embedding / vector** → list of floats (like `[0.1, 0.2, …]`)
* **Dimension** → size of that list (depends on embedding model, Gemini = `768`)
* **Metric** → how Pinecone decides similarity (`cosine`, `dotproduct`, `euclidean`)
* **Index** → your searchable collection of vectors
* **ID** → unique identifier for a vector (like `doc-1`)
* **Metadata** → JSON object stored with the vector (tags, source, etc.)
* **Filter** → search with conditions on metadata
* **Namespace** → optional sub-collections inside an index

---

## 🧰 Requirements

* 🔐 Pinecone account + API key
* 🧪 **Gemini embedding model** (`text-embedding-004`)
* 🧮 Know the embedding **dimension** (Gemini = `768`)
* 🧭 Decide **metric** (`cosine` is safe default for text)

---

## 🚦 Quick Start: End-to-End in JavaScript (with Gemini)

### 1) Install SDKs 🧱

```bash
npm install @pinecone-database/pinecone @google/generative-ai
```

### 2) Setup API Keys 🔑

In a `.env` file:

```env
PINECONE_API_KEY=your-pinecone-key
GOOGLE_API_KEY=your-gemini-key
```

### 3) Get embeddings 🧬 (Gemini)

```js
import { GoogleGenerativeAI } from "@google/generative-ai";

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY);

async function embedText(text) {
  const model = genAI.getGenerativeModel({ model: "text-embedding-004" });
  const res = await model.embedContent(text);
  return res.embedding.values; // array of floats
}

// Example
const vector = await embedText("Pinecone is a vector database.");
console.log("Vector length:", vector.length); // 768
```

> ✅ Note: Gemini’s **`text-embedding-004`** produces **768-dim vectors**.

---

### 4) Create a Pinecone Index 📦

```js
import { Pinecone } from "@pinecone-database/pinecone";

const pc = new Pinecone({ apiKey: process.env.PINECONE_API_KEY });

const indexName = "gemini-index";
const dimension = 768;  // match Gemini
const metric = "cosine";

// create index if not exists
const existing = await pc.listIndexes();
if (!existing.indexes.find(i => i.name === indexName)) {
  await pc.createIndex({
    name: indexName,
    dimension,
    metric,
    spec: { serverless: { cloud: "aws", region: "us-west-2" } }
  });
}

const index = pc.index(indexName);
```

---

### 5) Upsert (insert) vectors 📤

```js
const docs = [
  { id: "doc-1", text: "What is Pinecone? Pinecone is a vector DB...", source: "guide" },
  { id: "doc-2", text: "RAG improves LLM factuality by retrieving context...", source: "blog" }
];

const vectors = [];
for (const doc of docs) {
  const emb = await embedText(doc.text); // Gemini embedding
  vectors.push({
    id: doc.id,
    values: emb,
    metadata: { text: doc.text, source: doc.source }
  });
}

await index.upsert(vectors);
```

---

### 6) Query by meaning 🔍

```js
const query = "Explain RAG for chatbots";
const qEmb = await embedText(query);

const result = await index.query({
  vector: qEmb,
  topK: 5,
  includeMetadata: true,
  filter: { source: { $eq: "blog" } }
});

for (const match of result.matches) {
  console.log(match.id, match.score.toFixed(3), match.metadata.text.slice(0, 80) + "…");
}
```

---

### 7) Fetch / Update / Delete 🧹

```js
// fetch by ID
const fetched = await index.fetch(["doc-1"]);
console.log(fetched);

// update metadata
await index.update({
  id: "doc-1",
  setMetadata: { source: "guide-v2" }
});

// delete by ID
await index.deleteOne("doc-2");

// delete by filter
await index.deleteMany({ filter: { source: { $eq: "obsolete" } } });
```

---

### 8) Namespaces 🗂️

```js
await index.upsert(vectors, { namespace: "tenant-a" });

const res = await index.query({
  vector: await embedText("chatbots"),
  topK: 3,
  includeMetadata: true,
  namespace: "tenant-a"
});
```

---

## 🧠 Minimal RAG Flow (Web Dev view)

1. 📥 **Load docs** → (e.g., from file system or CMS)
2. ✂️ **Chunk** → break text into 500–800 token chunks
3. 🧬 **Embed** → call Gemini API → get vectors
4. 📦 **Upsert** → store in Pinecone with metadata
5. 🔎 **Query** → embed user input with Gemini → `index.query()`
6. 🧵 **Context** → insert retrieved chunks into LLM prompt

---

## 💡 Pro Tips

* Always use Gemini’s `text-embedding-004` → **768-dim**
* Use **cosine** similarity in Pinecone
* Batch embeddings for performance
* Store useful metadata (`source`, `url`) for filtering
* Use stable IDs (like `file:page:chunk`)
* Start with `topK=5` and adjust

---

## 🧯 Common Pitfalls

* **Dimension mismatch** → Pinecone must be `768` for Gemini
* **Index not ready** → wait a few seconds after creation
* **Bad retrieval** → must embed both docs + queries with Gemini
* **Filter issues** → check metadata JSON shape

---

## 📜 JavaScript Cheat Sheet (Gemini Edition)

**Embed**

```js
const vector = await embedText("Hello world");
```

**Create index**

```js
await pc.createIndex({
  name: "idx",
  dimension: 768,
  metric: "cosine",
  spec: { serverless: { cloud: "aws", region: "us-west-2" } }
});
```

**Upsert**

```js
await index.upsert([
  { id: "a1", values: vector, metadata: { text: "hello", source: "notes" } }
]);
```

**Query**

```js
await index.query({ vector, topK: 5, includeMetadata: true });
```

**Fetch / Update / Delete**

```js
await index.fetch(["a1"]);
await index.update({ id: "a1", setMetadata: { source: "notes-v2" } });
await index.deleteOne("a1");
```

**Namespaces**

```js
await index.upsert(vectors, { namespace: "tenant-123" });
await index.query({ vector, topK: 5, namespace: "tenant-123" });
```

---