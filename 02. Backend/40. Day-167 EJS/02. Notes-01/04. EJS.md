
# 🎯 What is **EJS**? — An in-depth explanation with examples ✨

**Quick answer:**  
**EJS (Embedded JavaScript)** is a simple templating language that lets you generate HTML on the server by embedding JavaScript inside template files. With EJS you can render dynamic pages (loops, conditionals, variables) and safely output data from your Node/Express backend.

---

## 🧠 Why use EJS?
- ✅ **Simple & familiar** — syntax is plain HTML with small JS snippets.  
- ✅ **Server-side rendering** — fast first paint, good for SEO and simple apps.  
- ✅ **Lightweight** — no heavy client bundle required.  
- ✅ **Integrates easily with Express** — `res.render()` and view engine support.  
Use when you want server-rendered pages (blogs, admin UIs, marketing pages) or to render HTML fragments for AJAX updates.

---

## 🛠️ Core syntax (the tags you’ll use)

- `<% code %>` — run JavaScript (no output).  
- `<%= value %>` — output **escaped** value (safe; recommended).  
- `<%- value %>` — output **unescaped/raw** HTML (dangerous if untrusted).  
- `<%# comment %>` — template comment (not output).  
- `<%%` and `%%>` — output literal `<%` or `%>` (escape a tag).

**Example**
```ejs
<h1>Welcome, <%= user.name %>!</h1>

<ul>
  <% posts.forEach(post => { %>
    <li><%= post.title %></li>
  <% }) %>
</ul>
```

---

## 🔒 Escaping & Security
- `<%= %>` escapes HTML by default → prevents XSS for inserted values.  
- Only use `<%- %>` for trusted HTML (e.g., sanitized rich text or HTML you generated).  
- Additional protections: sanitize user input on the server (libraries like `sanitize-html`), use CSRF tokens for forms, set security headers (`helmet()`).

---

## 🧩 Partials, Includes & Layouts
- **Partials / includes:** reuse header/footer or small pieces.
  ```ejs
  <%- include('partials/header') %>
  <!-- page content -->
  <%- include('partials/footer') %>
  ```
- **Layouts:** EJS itself has no built-in layout system, but use packages like `express-ejs-layouts` or `ejs-mate` to implement layouts (master template + content section).

---

## ⚙️ Express integration — minimal setup & example

**Install**
```bash
npm install express ejs
```

**server/index.js**
```js
const express = require('express');
const path = require('path');

const app = express();

// views location and engine
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

// static files
app.use(express.static(path.join(__dirname, 'public')));
app.use(express.urlencoded({ extended: true }));

// sample data
const posts = [{ id:1, title:'Hello EJS' }, { id:2, title:'Server rendered' }];

// render page
app.get('/', (req, res) => {
  res.render('index', { user: { name: 'Alice' }, posts });
});

// JSON API (coexists with EJS)
app.get('/api/posts', (req, res) => res.json(posts));

app.listen(3000, () => console.log('Server running on http://localhost:3000'));
```

**views/index.ejs**
```ejs
<!doctype html>
<html>
<head><meta charset="utf-8"><title>My EJS Site</title></head>
<body>
  <h1>Welcome, <%= user.name %> 👋</h1>

  <h2>Posts</h2>
  <ul>
    <% posts.forEach(p => { %>
      <li><%= p.title %></li>
    <% }) %>
  </ul>

  <form method="post" action="/posts">
    <input name="title" placeholder="New post" required>
    <button>Add</button>
  </form>
</body>
</html>
```

---

## 🧰 Helpers, locals & reusable logic
- **app.locals** — global helpers available to all views:
  ```js
  app.locals.formatDate = ts => new Date(ts).toLocaleString();
  ```
  then in EJS: `<%= formatDate(post.date) %>`

- **res.locals** — per-request values (e.g., `res.locals.csrfToken = req.csrfToken()`), often set by middleware.

---

## 📈 Performance & caching
- In production enable view caching:
  ```js
  app.set('view cache', true);
  ```
- EJS can compile templates to JS functions — reuse compiled functions for speed.  
- Avoid heavy computation inside templates — compute in controllers and pass ready data to the view.

---

## 📌 When to prefer EJS vs a client framework
- **Choose EJS** when:
  - You need quick server-rendered pages, SEO, or small/simple UIs.
  - You want minimal client-side JS and simpler deployment.
- **Choose SPA (React/Vue)** when:
  - You need rich interactive client UI, complex state, offline, or heavy client routing.
- You can mix: render main HTML with EJS and add small React/Vue widgets for interactivity.

---

## 🧾 File structure recommendation
```
/project
  /public         # css, client js, images
  /views
    /partials
    index.ejs
  /routes
  /controllers
  server.js
  package.json
```

---

## ✅ Best practices checklist
- Use `<%= %>` (escaped) for user content.  
- Only use `<%- %>` for sanitized/trusted HTML.  
- Keep template logic minimal — prefer controller/service for data prep.  
- Use partials for repeated UI (header/footer).  
- Provide globals via `app.locals` and per-request data via `res.locals`.  
- Enable caching in production; use CDN/long cache headers for static assets.  
- Protect forms with CSRF tokens and validate/sanitize inputs server-side.

---

## 🎯 Final takeaway
EJS is a **simple, powerful templating engine** for Node/Express that makes server-side HTML generation easy and safe (if you follow escaping/sanitizing rules). It’s perfect for SEO-friendly sites, simple admin panels, or mixed apps that also expose APIs.

---