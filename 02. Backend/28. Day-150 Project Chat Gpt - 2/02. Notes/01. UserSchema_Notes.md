
# 📘 **Deep Notes on Mongoose User Schema**

This document explains your `User` schema in **depth** so you can use it as a learning resource or documentation.

---

## 1️⃣ Importing Mongoose

```js
import mongoose from "mongoose";
```

✨ **Explanation:**

* ✅ Uses **ES Modules (ESM)** syntax (`import`) instead of CommonJS (`require`).
* ✅ `mongoose` is an ODM (**Object Data Modeling**) library for **MongoDB**.
* ✅ It allows:

  * Defining **schemas** (blueprints of data).
  * Adding **validation rules**.
  * Mapping those schemas to **MongoDB collections**.

---

## 2️⃣ Defining the Schema

```js
const userSchema = new mongoose.Schema({
   ...
}, { timestamps: true })
```

✨ **Explanation:**

* **`mongoose.Schema`** → defines how documents look inside a MongoDB collection.
* It lets you:

  * Enforce **required fields**.
  * Define **data types**.
  * Add **default values**.
  * Create **indexes** (e.g., `unique`).
* The **second argument** `{ timestamps: true }`:

  * Automatically adds two fields:

    * 🕒 `createdAt` → when the document was created.
    * 🔄 `updatedAt` → when the document was last modified.
  * ✅ Useful for **auditing and tracking** user activity.

---

## 3️⃣ Fields in the Schema

### ✉️ a) Email

```js
email: {
  type: String,
  required: true,
  unique: true
}
```

* 📌 **`type: String`** → only strings allowed.
* 📌 **`required: true`** → cannot be missing.
* 📌 **`unique: true`** → MongoDB ensures no duplicate emails (creates a unique index).
* ⚠️ **Important:** `unique` is **not a validator**—it’s enforced by the database, not by Mongoose.

---

### 👤 b) Full Name (Nested Object)

```js
fullName: {
  firstName: {
    type: String,
    required: true
  },
  lastName: {
    type: String,
    required: true
  }
}
```

* 👨‍💼 **Why nested object?**

  * Instead of one string (`"John Doe"`), you split it into **first name** and **last name**.
* ✅ Benefits:

  * Easy to **query/filter** by `firstName` or `lastName`.
  * Clean structure for user profiles.
* Both fields are **required**, ensuring a complete name.

---

### 🔑 c) Password

```js
password: {
  type: String
}
```

* Stored as a **string**.
* Notice → it’s **not required**.

  * This is flexible for cases like:

    * Social logins (Google, GitHub, etc.) where password may not be stored.
    * Guest accounts.
* ⚠️ **Security Best Practice:**

  * Never store raw passwords.
  * Always **hash passwords** using libraries like `bcrypt` before saving to DB.

---

## 4️⃣ Schema Options

```js
{
  timestamps: true
}
```

* 🕒 Automatically manages:

  * `createdAt`
  * `updatedAt`
* ✅ Saves effort: you don’t need to manually track when users register or update profiles.

---

## 5️⃣ Creating the Model

```js
const userModel = mongoose.model("user", userSchema)
```

✨ **Explanation:**

* **`mongoose.model()`** compiles the schema into a **model**.
* A model acts like a **class constructor**:

  * You can use it to create, read, update, and delete (`CRUD`) documents.
* `"user"` → MongoDB automatically **pluralizes** this into the `users` collection.
* `userSchema` → the blueprint we defined.

---

## 6️⃣ Exporting the Model

```js
export default userModel
```

✨ **Explanation:**

* Exports the model for use across your app.
* Usage Example:

  ```js
  import User from "./models/User.js";

  const newUser = await User.create({
    email: "test@example.com",
    fullName: { firstName: "John", lastName: "Doe" },
    password: "hashedPassword123"
  });
  ```

---

## ✅ Key Takeaways

* 📜 **Schema** → defines the structure of MongoDB documents.
* ✉️ `email` → required, unique, ensures no duplicate accounts.
* 👤 `fullName` → nested object, enforces first + last name.
* 🔑 `password` → optional, but **must be hashed**.
* 🕒 **Timestamps** → automatically track creation & updates.
* 🏗 **Model** → enables CRUD operations on the `users` collection.

---

## 🚀 Best Practices & Improvements (Optional)

1. **Email Validation**

   * Add regex to validate proper email format.

   ```js
   email: {
     type: String,
     required: true,
     unique: true,
     match: [/^\S+@\S+\.\S+$/, "Please enter a valid email"]
   }
   ```

2. **Password Hashing Middleware**

   * Use `pre('save')` hook to hash password before storing.
   * Example with `bcrypt`.

3. **Indexes**

   * Add compound indexes (e.g., if searching by `firstName + lastName`).

   ```js
   userSchema.index({ "fullName.firstName": 1, "fullName.lastName": 1 });
   ```

4. **Virtuals**

   * Add computed properties (e.g., `fullName` getter that returns `"John Doe"`).

---