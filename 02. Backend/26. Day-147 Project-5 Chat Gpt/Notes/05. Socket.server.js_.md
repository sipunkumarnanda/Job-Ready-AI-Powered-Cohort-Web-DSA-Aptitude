
# 📄 Code: `socket/socket.server.js`

```js
import { Server } from "socket.io";
import askAi from "../services/ai.service.js";

let aiMemory = []

function setupSocketServer(httpServer) {
  const io = new Server(httpServer, {});

  io.on("connection", (socket) => {
    console.log("A user connected");

    socket.on("ai-message", async(message)=>{
         aiMemory.push({ role: "user", parts : [{text : message}] });
         const result = await askAi(aiMemory)

        socket.emit("ai-message-response", result);
         aiMemory.push({ role: "model", parts : [{text : result}] });
    })

    socket.on("disconnect", () => {
      console.log("A user is disconnected");
    });
  });
}

export default setupSocketServer;
```

---

# 📝 Explanation with Notes

---

## 1. Importing Required Modules

```js
import { Server } from "socket.io";
import askAi from "../services/ai.service.js";
```

* 🌐 **Socket.io `Server`** → Creates a WebSocket server that enables **real-time, bidirectional communication** between client & server.
* 🤖 **askAi** → Function from `ai.service.js` to generate responses using Gemini AI.

---

## 2. AI Memory Store

```js
let aiMemory = []
```

* 🧠 Array to **store conversation history** (context of chat).
* Each message has:

  * `role` → `"user"` or `"model"`.
  * `parts` → array holding text messages.
* 🔄 Ensures the AI maintains **context** of past messages instead of answering in isolation.

---

## 3. Defining `setupSocketServer` Function

```js
function setupSocketServer(httpServer) {
  const io = new Server(httpServer, {});
```

* ⚙️ Function that sets up the **Socket.io server**.
* 🖥️ Accepts `httpServer` (your existing HTTP/Express server) and **attaches WebSocket capability**.
* 📡 `io` → main WebSocket server instance.

---

## 4. Handling Client Connections

```js
  io.on("connection", (socket) => {
    console.log("A user connected");
```

* 🔗 Fired whenever a client (browser) **connects**.
* 📌 `socket` → represents that **specific client’s connection**.
* 🖨️ Logs `"A user connected"` for monitoring.

---

## 5. Handling AI Chat Messages

```js
    socket.on("ai-message", async(message)=>{
         aiMemory.push({ role: "user", parts : [{text : message}] });
         const result = await askAi(aiMemory)

        socket.emit("ai-message-response", result);
         aiMemory.push({ role: "model", parts : [{text : result}] });
    })
```

* 📩 Listens for `"ai-message"` events from client (user sends a chat message).
* 📝 Steps:

  1. **Save user’s message** → push into `aiMemory` with `role: "user"`.
  2. **Ask AI** → call `askAi(aiMemory)` to generate AI’s response considering chat history.
  3. **Send response back** → use `socket.emit("ai-message-response", result)` to send AI’s reply to the same client.
  4. **Store AI’s reply** → push AI’s generated text into `aiMemory` with `role: "model"`.
* 🔄 This keeps a **continuous conversation flow** (like ChatGPT memory).

---

## 6. Handling Client Disconnects

```js
    socket.on("disconnect", () => {
      console.log("A user is disconnected");
    });
```

* 🚪 Fired when a user **disconnects** from server.
* 🖨️ Logs `"A user is disconnected"` for monitoring active users.

---

## 7. Exporting the Function

```js
export default setupSocketServer;
```

* 📦 Exports `setupSocketServer` so it can be used in your main app (e.g., `server.js`).
* 🧩 Example usage:

```js
import setupSocketServer from "./socket/socket.server.js";

const httpServer = app.listen(3000);
setupSocketServer(httpServer);
```

---

# 🌟 Summary

The `socket.server.js` enables **real-time AI chat** using Socket.io:

1. 🌐 Sets up a **WebSocket server** on top of your HTTP server.
2. 🧠 Maintains **conversation memory** (`aiMemory`) for context.
3. 📩 Listens for `"ai-message"` → saves user message → calls AI → sends AI response back.
4. 🔄 Keeps both user & AI messages in memory for contextual replies.
5. 🚪 Handles user **disconnect events** for clean logs.

---