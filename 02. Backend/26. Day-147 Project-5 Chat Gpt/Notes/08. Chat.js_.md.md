
# ðŸ“„ File: `public/scripts/chat.js`

---

## 1. ðŸŽ¬ DOMContentLoaded Event

```js
document.addEventListener("DOMContentLoaded", () => {
  // all code runs here
});
```

* Ensures that the script runs **only after HTML and DOM are fully loaded**.
* Prevents errors like `null` when querying elements that donâ€™t exist yet.

ðŸ‘‰ Always wrap frontend JS logic inside this event for safety.

---

## 2. ðŸ”Ž DOM Element References

```js
const sendBtn = document.querySelector(".send-btn");
const composerInput = document.querySelector("#composerInput");
const messagesContainer = document.querySelector("#messages");

const menuBtn = document.getElementById("menuToggle");
const sidebar = document.getElementById("sidebar");
const closeBtn = document.getElementById("closeSidebar");
```

* Gets references to important UI elements:

  * `sendBtn` â†’ send button (âž¤).
  * `composerInput` â†’ textarea where user types.
  * `messagesContainer` â†’ container holding all chat messages.
  * `menuBtn`, `sidebar`, `closeBtn` â†’ for mobile sidebar toggle.

ðŸ‘‰ These references allow us to manipulate the UI later.

---

## 3. ðŸ’¬ Create Message Function

```js
function createMessage(text, sender = "user") {
  if (!text.trim()) return; // ignore empty messages

  const messageEl = document.createElement("div");
  messageEl.classList.add("message", sender);

  const bubbleEl = document.createElement("div");
  bubbleEl.classList.add("bubble");
  bubbleEl.textContent = text;

  messageEl.appendChild(bubbleEl);
  messagesContainer.appendChild(messageEl);

  // scroll to bottom
  messagesContainer.scrollTop = messagesContainer.scrollHeight;
}
```

* Dynamically **creates a chat bubble** in the UI.
* Steps:

  1. Ignore empty messages.
  2. Create a `div.message` with a class (`user` or `assistant`).
  3. Add a `div.bubble` inside it containing the text.
  4. Append message to `#messages`.
  5. Auto-scroll to bottom so latest message is visible.

ðŸ‘‰ This is the **core function** to visually display messages in chat.

---

## 4. ðŸ“¤ Handle Sending a Message

```js
function handleSend() {
  const text = composerInput.value;
  socket.emit("ai-message", text);
  createMessage(text, "user");

  composerInput.value = "";
}
```

* **Reads user input** from textarea.
* Sends it to server via `socket.emit("ai-message", text)`.
* Immediately adds the message bubble in UI (`createMessage`).
* Clears input box.

ðŸ‘‰ Gives instant feedback to user while waiting for AIâ€™s reply.

---

## 5. ðŸ¤– Listening for AI Responses

```js
socket.on("ai-message-response", (response) => {
  createMessage(response, "assistant");
});
```

* Listens to **server response event** `"ai-message-response"`.
* Creates a **new assistant bubble** in chat with AI reply.
* âœ… Placed **once outside any function** â†’ avoids duplicate listeners.

ðŸ‘‰ This is how **real-time AI replies** are received.

---

## 6. ðŸ–±ï¸ UI Event Listeners

### a) Send Button

```js
sendBtn.addEventListener("click", handleSend);
```

* Click âž¤ triggers `handleSend()`.

---

### b) Enter Key Support

```js
composerInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    handleSend();
  }
});
```

* Press **Enter** â†’ sends message.
* **Shift+Enter** â†’ adds a new line.

ðŸ‘‰ Matches how real chat apps work.

---

### c) Sidebar Toggle (Mobile)

```js
menuBtn.addEventListener("click", () => {
  sidebar.classList.add("open");
});

closeBtn.addEventListener("click", () => {
  sidebar.classList.remove("open");
});
```

* Opens/closes sidebar on mobile with hamburger (â˜°) and close (âœ–) buttons.

---

## 7. ðŸšª Logout Feature

```js
const logoutBtn = document.querySelector(".logout-btn");

logoutBtn.addEventListener("click", async (e) => {
  e.preventDefault();

  const res = await fetch("/auth/logout", {
    method: "GET",
    credentials: "include", // important: send cookies
  });

  if (res.redirected) {
    window.location.href = res.url;
  } else {
    window.location.href = "/auth/login";
  }
});
```

* Listens for logout button click.
* Sends `GET` request â†’ `/auth/logout`.
* `credentials: "include"` â†’ ensures cookies (like JWT token) are sent.
* If server redirects â†’ follow automatically.
* Otherwise â†’ fallback redirect to `/auth/login`.

ðŸ‘‰ Ensures secure logout process + proper session cleanup.

---

# ðŸŽ¯ Big Picture (How Everything Works)

1. User types message â†’ hits send.
2. `handleSend()` â†’ sends message to server with `socket.emit`.
3. Server (from your earlier `socket.server.js`) processes message â†’ asks AI â†’ sends back response.
4. Client listens via `socket.on("ai-message-response")` â†’ adds AI message bubble.
5. UI updates instantly â†’ just like ChatGPT.
6. Logout works via `/auth/logout`.

---

âœ… These notes will help you **never forget the flow**:

* **User Input â†’ Socket Emit â†’ Server AI â†’ Socket Response â†’ UI Update**

---