
# ü§ñüíª MCP Server & Client: AI Function Calls Explained in Depth üõ†Ô∏è‚ú®

This note explains in detail how an MCP client interacts with an MCP server, how all available tools are passed to AI via `functionDeclarations`, how AI decides which tool to call, and how the results are executed and returned.

---

## üîπ 1Ô∏è‚É£ What Are Tools on MCP Server?

The **MCP server** is where all your functions (tools) are registered. Each tool has:

* **Name** ‚Üí Identifier for the tool (`addTwoNumbers`)
* **Description** ‚Üí Explains what the tool does (`Add two numbers`)
* **Input schema** ‚Üí Defines expected inputs (e.g., `a` and `b` as numbers)

Example:

```json
[
  {
    "name": "addTwoNumbers",
    "description": "Add two numbers",
    "parameters": {
      "type": "OBJECT",
      "properties": {
        "a": { "type": "number" },
        "b": { "type": "number" }
      },
      "required": ["a", "b"]
    }
  }
]
```

‚úÖ Each tool is **well-described**, so both AI and client know how to use it.

---

## üîπ 2Ô∏è‚É£ Passing Tools to AI: `functionDeclarations`

In your client code:

```javascript
const aiResponse = await ai.models.generateContent({
  model: 'gemini-2.0-flash',
  contents: "Add 2 and 3",
  config: {
    tools: [{
      functionDeclarations: tools
    }]
  }
});
```

### What Happens Here:

* `functionDeclarations: tools` gives AI **a complete list of all tools registered on the MCP server**.
* AI now knows:

  * Which tools are available
  * How to call them (names, input parameters)
  * What each tool does (description)

üí° Think of this as giving the AI a **menu of all available functions**.

---

## üîπ 3Ô∏è‚É£ How AI Chooses the Appropriate Tool

1. **AI receives the prompt**:

```javascript
contents: "Add 2 and 3"
```

2. **AI analyzes the prompt**:

   * Compares it against all `functionDeclarations`
   * Looks for the best match based on:

     * Tool name
     * Description
     * Input parameters

3. **AI selects the most appropriate tool**:

   * Example: Chooses `addTwoNumbers` because the prompt is a simple addition and matches the input schema (`a` and `b`).

4. **AI returns a planned function call**:

```json
{
  "functionCalls": [
    {
      "name": "addTwoNumbers",
      "args": { "a": 2, "b": 3 }
    }
  ]
}
```

* `name` ‚Üí Tool the AI wants to call
* `args` ‚Üí Arguments AI thinks should be passed

---

### üîπ Key Points:

* ‚úÖ AI chooses the **best matching tool** even if there are many tools on the server.
* ‚ö†Ô∏è AI does **not execute the function** itself. It only **plans the function call**.
* The **client executes the tool** using `client.callTool()`.

---

## üîπ 4Ô∏è‚É£ Executing the Tool via MCP Client

After receiving `aiResponse`, the client executes the tool:

```javascript
aiResponse.functionCalls.forEach(async (call) => {
  const toolResponse = await client.callTool({
    name: call.name,
    arguments: call.args
  });
  console.log("Tool Response:", toolResponse);
});
```

### How This Works:

1. `client.callTool()` sends the request to the **MCP server**.
2. The MCP server **validates input** and executes the tool.
3. The result is returned to the client.

Example result for `addTwoNumbers`:

```json
{
  "content": [
    { "type": "text", "text": "5" }
  ]
}
```

‚úÖ So the **AI decides what to call**, and the **server executes it and returns the result**.

---

## üîπ 5Ô∏è‚É£ Complete Flow: Step by Step

| Step | Who Does It     | Action                                                  |
| ---- | --------------- | ------------------------------------------------------- |
| 1Ô∏è‚É£  | MCP Server      | Registers tools (`addTwoNumbers`, etc.)                 |
| 2Ô∏è‚É£  | MCP Client      | Fetches all tools and creates `functionDeclarations`    |
| 3Ô∏è‚É£  | MCP Client ‚Üí AI | Sends user prompt + tools to AI                         |
| 4Ô∏è‚É£  | AI              | Analyzes prompt and selects appropriate tool(s)         |
| 5Ô∏è‚É£  | AI              | Returns `aiResponse.functionCalls` (planned tool calls) |
| 6Ô∏è‚É£  | MCP Client      | Calls each tool on server using `client.callTool()`     |
| 7Ô∏è‚É£  | MCP Server      | Executes tool and returns result                        |
| 8Ô∏è‚É£  | MCP Client      | Receives tool output and prints/logs it                 |

---

### üîπ 6Ô∏è‚É£ Analogy

Think of AI as a **chef** in a kitchen:

1. You give the chef a **menu** ‚Üí `functionDeclarations: tools`
2. You tell the chef your order ‚Üí `contents: "Add 2 and 3"`
3. Chef decides the **right recipe/tool** ‚Üí `aiResponse.functionCalls`
4. Kitchen staff (MCP server via client) **prepares the dish** ‚Üí `client.callTool()`
5. Dish is served ‚Üí `toolResponse`

üçΩÔ∏è This ensures AI only **plans**, while execution is safe and validated by the server.

---

### üîπ 7Ô∏è‚É£ Summary

* `functionDeclarations` = **AI‚Äôs menu of available tools**
* AI reads your **prompt** and decides which tool fits best
* `aiResponse.functionCalls` = **planned function call, not executed result**
* `client.callTool()` = **executes the tool on MCP server**
* Flow ensures **AI decision + server execution + validated results**

---