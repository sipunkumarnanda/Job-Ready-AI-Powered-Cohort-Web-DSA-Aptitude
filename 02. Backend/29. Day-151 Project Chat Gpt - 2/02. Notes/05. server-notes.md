
# 🌐 Server Setup (`server.js`)

---

## 🛠️ Full Code

```javascript
import app from "./src/app.js";
import connectDB from "./src/db/db.js";
import initSocketServer from "./src/socket/socket.server.js";
import http from 'http'
import dotenv from 'dotenv'

dotenv.config()

const httpServer = http.createServer(app)
initSocketServer(httpServer)

connectDB()

httpServer.listen(3000, (()=>{
    console.log("Server is running on port 3000");
}))
```

---

## 📖 Detailed Notes on Modules and Functionality

---

### 1️⃣ **App Module**

```javascript
import app from "./src/app.js";
```

* `app` is an **Express application instance**.
* Handles **HTTP routes**, middleware, and request/response logic.
* Provides REST API endpoints for your backend (e.g., login, register, chat history).

---

### 2️⃣ **Database Connection**

```javascript
import connectDB from "./src/db/db.js";
connectDB()
```

* `connectDB` establishes a **connection to MongoDB** using Mongoose.
* Ensures the app can **store and retrieve data** like users, chats, and messages.
* Typically handles **connection errors, reconnection attempts, and logs**.

---

### 3️⃣ **Socket Server Initialization**

```javascript
import initSocketServer from "./src/socket/socket.server.js";
initSocketServer(httpServer)
```

* Initializes a **WebSocket server** using Socket.IO.
* Allows **real-time communication** for features like AI chat messages, notifications, and live updates.
* Requires an **HTTP server** as a base (see explanation below).

---

### 4️⃣ **HTTP Module**

```javascript
import http from 'http'
const httpServer = http.createServer(app)
```

* Creates a **Node.js HTTP server** that wraps the Express `app`.
* Purpose:

  1. Allows **Express routes** to handle standard HTTP requests.
  2. Provides a **base server** for Socket.IO to attach and handle WebSocket connections.
* Why needed?

  * Socket.IO cannot directly work with Express alone.
  * WebSocket connections need an HTTP server to **perform the handshake** before upgrading to a WebSocket.

---

### 5️⃣ **Environment Variables**

```javascript
import dotenv from 'dotenv'
dotenv.config()
```

* Loads `.env` file for **sensitive configurations**, like database URLs or API keys.
* Keeps credentials out of source code for security.

---

### 6️⃣ **Starting the Server**

```javascript
httpServer.listen(3000, (()=>{
    console.log("Server is running on port 3000");
}))
```

* **Listens on port 3000** for incoming HTTP and WebSocket connections.
* Prints a **confirmation message** to the console.
* The HTTP server now serves **both REST APIs and real-time sockets**.

---

## ⚡ Why Do We Need an HTTP Server Here?

### 🔹 Express Alone Is Not Enough

* `app` (Express instance) can handle **HTTP requests**, but **WebSockets require an actual server object**.
* Socket.IO needs to **attach to a server instance** to perform the WebSocket handshake.

### 🔹 WebSocket Handshake

* WebSockets initially start as a **HTTP request** to upgrade the connection.
* The HTTP server allows Socket.IO to **listen for upgrade requests** and then establish a persistent WebSocket.

### 🔹 Unified Server

* By creating `httpServer`:

  * REST API endpoints (`app`) work.
  * Socket.IO real-time events (`initSocketServer`) work on the same port.
* Avoids running **two separate servers** (one for HTTP and one for WebSockets), simplifying deployment and networking.

---

### 🔑 Key Takeaways

* `server.js` sets up a **full backend server** combining:

  1. Express app (HTTP routes)
  2. MongoDB connection (data persistence)
  3. Socket.IO (real-time communication)
* `http.createServer(app)` is **crucial** to enable both HTTP and WebSocket connections on the same port.
* Modular structure keeps your app **scalable, maintainable, and secure**.

---