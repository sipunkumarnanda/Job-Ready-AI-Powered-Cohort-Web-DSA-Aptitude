
# 🚀 Socket Server Setup (`socket.server.js`)

---

## 🛠️ Full Code

```javascript
import { Server } from "socket.io";
import cookie from "cookie";
import jwt from "jsonwebtoken";
import userModel from "../models/user.model.js";
import generateResponse from "../services/ai.service.js";
import messageModel from "../models/message.model.js";

function initSocketServer(httpServer) {
  const io = new Server(httpServer, {});

  io.use(async (socket, next) => {
    const cookies = cookie.parse(socket.handshake.headers?.cookie || "");

    if (!cookies.token) {
      next(new Error("Authentication error : No token provided"));
    }

    try {
      const decoded = jwt.verify(cookies.token, process.env.JWT_SECRETE);

      const user = await userModel.findById(decoded.id);

      socket.user = user;
      next();

    } catch (error) {
      next(new Error("Authentication error : Invalid token"));
    }

  });

  io.on("connection", (socket) => {
   
    socket.on("ai-message", async(messagePayload) => {
      await  messageModel.create({
        chatId : messagePayload.chatId,
        userId : socket.user._id,
        content : messagePayload.content,
        role : "user"
      })

      const chatHistory = (await messageModel.find({
        chatId : messagePayload.chatId
      }).sort({createdAt : -1}).limit(20).lean()).reverse()

      const response = await generateResponse(chatHistory.map((item)=>{
        return {
          role : item.role,
          parts : [{text : item.content}] 
        }
      }))
      
       await  messageModel.create({
        chatId : messagePayload.chatId,
        userId : socket.user._id,
        content : response,
        role : "model"
      })

       socket.emit('ai-response', {
        chat : messagePayload.chat , 
        content : response
      })

    });

    socket.on("disconnect", () => {
      console.log("A user is disconnected");
    });
  });
}

export default initSocketServer;
```

---

## 📖 Detailed Notes on Modules and Functionality

---

### 1️⃣ **Socket.io (`Server`)**

```javascript
import { Server } from "socket.io";
```

* **Purpose:** Sets up a **WebSocket server** to allow real-time bi-directional communication between client and server.

* **Usage in code:**

  ```javascript
  const io = new Server(httpServer, {});
  ```

  * Wraps an existing HTTP server for real-time capabilities.
  * `io.on("connection", ...)` listens for new clients connecting.

* **Benefits:**

  * Instant messaging, live updates, notifications.
  * Lightweight alternative to HTTP polling.

---

### 2️⃣ **Cookie Parsing (`cookie`)**

```javascript
import cookie from "cookie";
```

* **Purpose:** Parse cookies from the incoming HTTP headers.
* **Usage:**

  ```javascript
  const cookies = cookie.parse(socket.handshake.headers?.cookie || "");
  ```

  * Extracts the `token` cookie from the handshake request.
  * Necessary for **authentication** before allowing the socket connection.

---

### 3️⃣ **JWT (`jsonwebtoken`)**

```javascript
import jwt from "jsonwebtoken";
```

* **Purpose:** Handle **JSON Web Token** verification for authentication.

* **Usage:**

  ```javascript
  const decoded = jwt.verify(cookies.token, process.env.JWT_SECRETE);
  ```

  * Verifies that the token sent by the client is **valid and unexpired**.
  * Extracts the `id` of the authenticated user.

* **Security:**

  * Ensures only **authenticated users** can open socket connections.
  * Invalid or missing tokens throw an error and deny access.

---

### 4️⃣ **User Model (`userModel`)**

```javascript
import userModel from "../models/user.model.js";
```

* **Purpose:** Fetch user details from MongoDB.

* **Usage:**

  ```javascript
  const user = await userModel.findById(decoded.id);
  socket.user = user;
  ```

  * Attaches the user object to the socket for **authenticated actions**.

* **Benefit:**

  * Allows socket events to access the user directly (`socket.user._id`).

---

### 5️⃣ **Message Model (`messageModel`)**

```javascript
import messageModel from "../models/message.model.js";
```

* **Purpose:** Store and retrieve messages in MongoDB.

* **Usage:**

  ```javascript
  await messageModel.create({ ... })
  const chatHistory = await messageModel.find({ ... })
  ```

  * Saves **user messages** and **AI responses**.
  * Retrieves recent messages to **generate context-aware AI replies**.

* **Key Notes:**

  * `.sort({createdAt: -1}).limit(20).lean()` fetches **last 20 messages** in reverse order.
  * `.lean()` returns **plain JS objects** instead of Mongoose documents (more efficient).

---

### 6️⃣ **AI Response Service (`generateResponse`)**

```javascript
import generateResponse from "../services/ai.service.js";
```

* **Purpose:** Call an **AI service** to generate model responses based on message history.
* **Usage:**

  ```javascript
  const response = await generateResponse(chatHistory.map(item => ({
      role: item.role,
      parts: [{ text: item.content }]
  })))
  ```

  * Converts chat history into AI-understandable format.
  * Returns **text response** that is then saved and emitted back to the client.

---

### 7️⃣ **Socket Middleware (`io.use`)**

```javascript
io.use(async (socket, next) => { ... });
```

* **Purpose:** **Authenticate users** before establishing a socket connection.
* **Steps:**

  1. Parse cookies.
  2. Check if `token` exists.
  3. Verify JWT token.
  4. Fetch user from DB and attach to `socket.user`.
* **Error Handling:**

  * Missing or invalid token → `next(new Error("Authentication error"))`.

---

### 8️⃣ **Socket Event: `ai-message`**

```javascript
socket.on("ai-message", async(messagePayload) => { ... });
```

* **Purpose:** Handles messages sent by users to AI.

* **Flow:**

  1. Save the **user message** in DB.
  2. Retrieve **last 20 messages** for context.
  3. Generate **AI response** using `generateResponse`.
  4. Save **AI response** in DB.
  5. Emit `ai-response` back to the client.

* **Notes:**

  * Uses `socket.user._id` to link messages to the authenticated user.
  * Ensures conversation is **contextual** using recent message history.

---

### 9️⃣ **Socket Event: `disconnect`**

```javascript
socket.on("disconnect", () => {
  console.log("A user is disconnected");
});
```

* **Purpose:** Logs whenever a user **disconnects** from the socket server.
* Helps in **monitoring and cleanup** of active connections.

---

### 🔑 Key Takeaways

* This file sets up a **secure, real-time chat server** with:

  * **Authentication** (JWT + cookies)
  * **User-specific sessions** (`socket.user`)
  * **Persistent messaging** (MongoDB via Mongoose)
  * **AI-powered responses**
  * **Event-driven communication** (`ai-message`, `disconnect`)

* **Structure:**

  ```
  HTTP Server → Socket.IO → Middleware (auth) → Events → DB + AI
  ```

---