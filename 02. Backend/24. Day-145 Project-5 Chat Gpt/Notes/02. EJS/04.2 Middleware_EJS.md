
# üîß `app.set("view engine", "ejs")` ‚Äî What, why & deep details

### ‚ûï What this does (short)

Tells Express: **‚ÄúWhen I call `res.render('name')`, use EJS to compile `views/name.ejs` into HTML.‚Äù**
Express uses the view engine to convert templates into final HTML sent to the browser.

### üß† How it works (under the hood)

* Express keeps a mapping of file extensions ‚Üí rendering functions.
* `app.set("view engine", "ejs")` registers `.ejs` as the default template type.
* When you call `res.render('index', data)`, Express:

  1. Looks for a file at `views/index.ejs` (by default `views/` folder).
  2. Calls the EJS renderer to compile the template and inject `data`.
  3. Sends the resulting HTML back to the client.

### ‚úÖ Practical usage example

```js
// app.js
import path from 'path';
app.set('views', path.join(process.cwd(), 'views')); // explicit views path
app.set('view engine', 'ejs');

// route
router.get('/', (req, res) => {
  res.render('index', { title: 'Home', user: { name: 'Sipun' } });
});
```

In `views/index.ejs`:

```ejs
<title><%= title %></title>
<h1>Hi, <%= user.name %>!</h1>
```

### ‚öôÔ∏è Useful options & helpers

* `app.set('views', path)` ‚Äî set the directory for templates (always good to do).
* `app.set('view cache', true)` ‚Äî enable template caching (production).
* `app.locals` and `res.locals` ‚Äî share global variables/helpers with all views:

  ```js
  app.locals.siteName = "My App";
  res.locals.user = req.user; // available for one response
  ```

### üîê Security notes

* Always **escape user content** in templates: use `<%= value %>` which escapes HTML.
* Only use `<%- html %>` (unescaped) for content you fully control or sanitized (e.g., sanitized Markdown ‚Üí HTML).
* Prevent template injection by never passing untrusted template code into `res.render`.

### ‚ö†Ô∏è Common pitfalls

* Forgetting to set `views` path ‚Üí Express can‚Äôt find templates.
* Running in production without view cache ‚Üí slower.
* Heavy logic inside templates ‚Üí performance/maintainability issues (keep templates simple).

---

# üì¶ `app.use(express.json())` ‚Äî Parse JSON bodies (APIs & webhooks)

### ‚ûï What this does (short)

Registers middleware that parses incoming **`application/json`** request bodies and populates `req.body` with the parsed object.

### üß† How it works

* This is built on the `body-parser` module (now included in Express).
* When a request has header `Content-Type: application/json`, the middleware:

  1. Buffers the request body.
  2. Parses JSON into an object using `JSON.parse`.
  3. Sets `req.body = parsedObject`.
* If parsing fails (malformed JSON), Express throws a `400 Bad Request` by default.

### ‚úÖ Example

Client:

```http
POST /api/items
Content-Type: application/json

{"name":"Keyboard", "price":49.99}
```

Server:

```js
app.use(express.json());
app.post('/api/items', (req, res) => {
  const { name, price } = req.body; // parsed already
  // save to DB...
  res.status(201).json({ ok: true });
});
```

### ‚öôÔ∏è Options & advanced usage

`express.json([options])` supports:

* `limit` ‚Äî max body size (e.g., `'100kb'`). Must set to prevent DoS from huge payloads:

  ```js
  app.use(express.json({ limit: '10kb' }));
  ```
* `type` ‚Äî content types to parse (default `application/json`).
* `verify` ‚Äî function to capture raw body for signature verification (see Stripe/webhook example below).

### üîí Security & reliability tips

* **Always set a small `limit`** (e.g., `'10kb'`‚Äì`'100kb'`) for typical JSON APIs; large limits can enable memory exhaustion attacks.
* **Handle parse errors** with an error middleware so you can respond with a helpful message.
* For **webhooks requiring signature verification** (Stripe, GitHub), you usually need the **raw** request body to compute the signature ‚Äî you must apply `express.raw()` for that route *before* `express.json()`. Example:

  ```js
  import express from 'express';
  app.post('/webhook', express.raw({ type: 'application/json' }), (req, res) => {
    const raw = req.body; // Buffer with raw bytes
    verifySignature(raw, req.headers['stripe-signature']);
    res.sendStatus(200);
  });
  ```

  If you globally use `express.json()`, ensure route-specific raw middleware runs earlier or disable json for that route.

### ‚ö†Ô∏è Common pitfalls

* No `limit` ‚Üí attacker can send multi-GB JSON payloads, causing memory issues.
* Applying `express.json()` after routes that expect `req.body` will result in `req.body` being undefined. **Order matters.**

---

# üßæ `app.use(express.urlencoded({ extended: true }))` ‚Äî Parse HTML form data

### ‚ûï What this does (short)

Parses `application/x-www-form-urlencoded` request bodies (typical for standard HTML `<form method="POST">`) and populates `req.body`.

### üß† How it works

* `express.urlencoded()` uses the `qs` library (when `extended: true`) to parse URL-encoded strings into objects, allowing nested structures.
* Example form submission body: `name=John&items[]=apple&items[]=mango&user[age]=30`
  With `extended: true` you get:

  ```js
  req.body = {
    name: 'John',
    items: ['apple','mango'],
    user: { age: '30' }
  }
  ```

### ‚úÖ Example

HTML:

```html
<form action="/submit" method="post">
  <input name="name" />
  <input name="user[email]" />
  <button>Send</button>
</form>
```

Server:

```js
app.use(express.urlencoded({ extended: true }));
app.post('/submit', (req, res) => {
  console.log(req.body); // parsed form data
  res.redirect('/');
});
```

### üõ† Options & differences

* `extended: true` ‚Äî uses `qs` and supports nested objects (recommended for complex forms).
* `extended: false` ‚Äî uses `querystring` and only supports simple key-value pairs.

Also supports `limit` like `express.json`:

```js
app.use(express.urlencoded({ extended: true, limit: '50kb' }));
```

### üîê Security & best practices

* For **file uploads**, DO NOT use `express.urlencoded()`; file uploads use `multipart/form-data` which requires `multer` or similar middleware.
* Validate and sanitize form fields server-side ‚Äî never trust client input.
* Use CSRF protection (e.g., `csurf`) for server-rendered apps with forms.

### ‚ö†Ô∏è Common pitfalls

* Expecting nested objects but using `extended: false` ‚Üí `req.body` will be flat strings.
* Forgetting `express.urlencoded()` for forms ‚Üí `req.body` undefined.

---

# üìÅ `app.use(express.static('public'))` ‚Äî Serving static assets

### ‚ûï What this does (short)

Serves files from the `public/` folder directly to clients. If the browser requests `/style.css`, Express will return `public/style.css` (if it exists), without hitting your route handlers.

### üß† How it works

* `express.static(root, [options])` creates middleware that:

  * Checks the URL path.
  * Maps it to a file path under `root`.
  * Streams the file content back with correct MIME type.
* This bypasses your routes and template rendering for static assets (faster).

### ‚úÖ Basic example

```js
app.use(express.static('public'));
// public/style.css -> available at /style.css
// public/js/app.js -> available at /js/app.js
```

In your EJS: `<link href="/style.css" rel="stylesheet">` and `<script src="/script.js"></script>`.

### ‚öôÔ∏è Important options (use these in real apps)

When you want control, pass options:

```js
app.use(express.static(path.join(__dirname, 'public'), {
  dotfiles: 'ignore',       // ignore hidden files
  index: false,             // disable directory index
  maxAge: '1d',             // cache-control max-age
  redirect: false,          // don't redirect to trailing slash
  setHeaders: (res, path) => {
    // set custom headers (e.g., CSP, cache-control)
    res.set('X-Content-Type-Options', 'nosniff');
  }
}));
```

### üßæ Caching & CDN strategy

* **Cache-Control**: use `maxAge` for browser caching; for immutable assets set a long `maxAge` and use fingerprinted filenames (`app.ab12cd.css`).
* **CDN**: In production, serve static assets via a CDN (Cloudfront, Cloudflare, S3) for global performance. You can still use `express.static` in local/dev.
* **Pre-compressed files**: Consider serving gzipped/brotli files or use `compression()` middleware to compress responses on the fly (but serving precompressed is more efficient on high scale).

### üîí Security notes

* Keep **sensitive files out** of `public/` (never place `.env`, `node_modules`, or private data there).
* `dotfiles: 'ignore'` prevents exposing `.env` or `.git` if they accidentally land in `public/`.
* Use `setHeaders` to add `content-security-policy` or `X-Frame-Options` if needed for static resources.

### ‚ö†Ô∏è Common pitfalls

* Using relative paths in templates like `href="style.css"` can sometimes resolve unexpectedly if you have nested routes‚Äîprefer absolute `/style.css`.
* Serving dynamic content from `public/` (templates) will not be processed ‚Äî static files are raw.
* Forgetting to fingerprint versioned files leads to cache-busting issues on deploy.

---

# üîÅ Middleware order ‚Äî the single most important rule üìè

Middleware order in Express matters a lot:

* Put **parsers & security middleware** (helmet, compression, body parsers) **before** your routes.
* Put **`express.static`** early if you want static responses served quickly (but put security headers before it if necessary).
* Put **route handlers** after middleware.
* Put **error handlers** (`app.use((err,req,res,next)=>...)`) last.

Example order:

```js
app.use(helmet());
app.use(compression());
app.use(express.static('public'));
app.use(express.json({ limit: '10kb' }));
app.use(express.urlencoded({ extended:true }));
app.use(router);            // your routes
app.use(errorHandler);      // final error handling middleware
```

---

# üß∞ Extras: monitoring, debugging & production tips

* **Error handling** for body parsing:

  ```js
  app.use((err, req, res, next) => {
    if (err.type === 'entity.too.large') {
      return res.status(413).send('Payload too large');
    }
    next(err);
  });
  ```
* **Dev tooling**: use `nodemon` for auto-restart on file changes.
* **Logging**: `morgan('dev')` in development; `pino` or `winston` for production.
* **Security**: `helmet()` adds secure headers; remove `X-Powered-By` header with `app.disable('x-powered-by')`.
* **Compression**: `app.use(compression())` to gzip responses (useful for HTML/CSS/JSON).

---

# ‚úÖ Quick checklist & recommended settings (copy-paste)

```js
import express from 'express';
import path from 'path';
import helmet from 'helmet';
import compression from 'compression';
import morgan from 'morgan';

const app = express();

// security & perf
app.disable('x-powered-by');
app.use(helmet());
app.use(compression());
app.use(morgan('combined'));

// views
app.set('views', path.join(process.cwd(), 'views'));
app.set('view engine', 'ejs');
app.set('view cache', process.env.NODE_ENV === 'production');

// static files (safe settings)
app.use(express.static(path.join(process.cwd(), 'public'), {
  dotfiles: 'ignore',
  index: false,
  maxAge: '7d',
  setHeaders(res, filePath) {
    if (filePath.endsWith('.html')) {
      res.setHeader('Cache-Control', 'no-cache');
    }
  }
}));

// parsers with limits
app.use(express.json({ limit: '50kb' }));
app.use(express.urlencoded({ extended: true, limit: '50kb' }));

// routes...
```

---

# üßæ Summary (short & actionable)

* `app.set("view engine", "ejs")` ‚Üí Configure server-side HTML rendering with EJS. Use `<%= %>` for safe output and `app.set('views', ...)` to be explicit.
* `app.use(express.json())` ‚Üí Parse JSON bodies for APIs. Always set a `limit` and handle webhook special cases with `express.raw()` where necessary.
* `app.use(express.urlencoded({ extended: true }))` ‚Üí Parse HTML form POSTs, supports nested fields when `extended: true`. Use `multer` for file uploads.
* `app.use(express.static('public'))` ‚Üí Serve CSS/JS/images fast. Configure caching, dotfile handling, and headers; prefer CDN in production.

---

If you want, I can now:

* Show a **secure ready-to-run `app.js`** using all recommended settings above, or
* Modify your `index.ejs` and `routes` to demonstrate **dynamic rendering** (`res.render('index', { title, items })`) and CSRF-protected form submission.