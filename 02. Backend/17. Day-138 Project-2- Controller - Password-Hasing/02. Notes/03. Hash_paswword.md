
## ğŸ” Why Do We Store Passwords as **Hashes** and Not as Plain Text?

---

### â“ **Question: Why shouldn't we save user passwords in plain text in a database, and why use hashing instead?**

---

## ğŸš¨ 1. **Plain Text Passwords Are a Massive Security Risk**

If you store passwords in **plain text**, it means anyone with access to your database (legitimately or through hacking) can **read every userâ€™s password directly**.

### ğŸ”´ Real-world Danger:

Imagine your database is leaked or hacked. If passwords are stored in plain text:

* Every user's password is instantly compromised.
* Users often reuse passwords across platforms â€” so one leak can lead to multiple account hacks (emails, banking, etc.).

---

## ğŸ›¡ï¸ 2. **What Is Hashing?**

### ğŸ”‘ Hashing = One-Way Encryption

* A **hash function** turns a password into a long, scrambled string (e.g., `5f4dcc3b5aa765d61d8327deb882cf99`).
* **Itâ€™s irreversible** â€” you can't turn the hash back into the original password.
* You **compare hashes**, not decrypt them.

> ğŸ”„ You store the **hashed password** in your DB. When a user logs in, you **hash the input** and compare it with the stored hash.

---

## âš™ï¸ 3. **How Password Hashing Works (With Bcrypt)**

1. User enters password: `mypassword123`
2. You hash it using a library like bcrypt:

   ```js
   const hashed = await bcrypt.hash('mypassword123', 10);
   // Result: $2b$10$h8HNa3k... (a long string)
   ```
3. Store this hash in the database.

ğŸ” When user logs in:

* You donâ€™t decrypt the hash.
* You hash the input again and use:

  ```js
  bcrypt.compare(plainPassword, hashedPasswordFromDB)
  ```

---

## ğŸ§± 4. **Why Hashing Is Better Than Encryption**

| Feature         | Hashing                                | Encryption                             |
| --------------- | -------------------------------------- | -------------------------------------- |
| One-way?        | âœ… Yes                                  | âŒ No (can be reversed)                 |
| Use case        | Passwords, fingerprints                | Secure messages, files                 |
| Decryption key? | âŒ No key needed                        | âœ… Key required                         |
| Database risk   | Low (hash is useless without password) | High (encrypted data can be decrypted) |

---

## ğŸ›¡ï¸ 5. **What If You Donâ€™t Hash Passwords?**

### ğŸ”´ Consequences:

* **Immediate data breach** if database is leaked
* **Legal and compliance issues** (e.g., GDPR, HIPAA)
* **Loss of user trust**
* Damage to your company's reputation (think: Facebook, Yahoo, Adobe breaches)

---

## âœ… 6. **Best Practices for Storing Passwords**

1. **Use a strong hash algorithm** like `bcrypt`, `argon2`, or `scrypt`.
2. **Never write your own hash logic.** Use trusted libraries.
3. Always add a **salt** (random data) â€” bcrypt handles this automatically.
4. Never log or expose password hashes publicly.

---

## ğŸ”š Summary: Why Store Passwords as Hashes?

| Reason                  | Description                                          |
| ----------------------- | ---------------------------------------------------- |
| **Security**            | Hashing protects user passwords from being leaked    |
| **Irreversible**        | Hashes canâ€™t be converted back to plain passwords    |
| **Safe Comparisons**    | You compare hashes, not decrypt                      |
| **Legal Compliance**    | Required under data protection laws                  |
| **Trustworthy Systems** | Users trust systems that handle credentials securely |

---