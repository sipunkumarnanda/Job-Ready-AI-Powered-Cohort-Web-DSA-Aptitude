
# ğŸ” Authentication Middleware in Express â€“ Explained

In modern web applications, especially those with **user authentication**, it's common to have certain routes (APIs) that should only be accessible to **logged-in users**. To ensure this, we create a **middleware** that checks the user's authentication before allowing access.

---

## âœ… What Is Middleware?

In Express.js, middleware functions are functions that have access to the **request**, **response**, and the **next** function in the applicationâ€™s request-response cycle. Middleware can be used to:

* Authenticate users
* Log requests
* Validate data
* Handle file uploads
* And much more

---

## ğŸ§  Why Create a Separate Authentication Middleware?

When multiple API routes require the **same logic to authenticate a user**, writing this logic in every controller leads to:

* Code duplication
* Maintenance difficulties
* Poor scalability

**Solution:** Create a reusable middleware function that performs the authentication once and can be imported wherever needed.

---

## ğŸ“ Folder Structure Used

```
src/
â”œâ”€â”€ middlewares/
â”‚   â””â”€â”€ auth.middleware.js
â”œâ”€â”€ controllers/
â”‚   â””â”€â”€ post.controller.js
â”œâ”€â”€ models/
â”‚   â””â”€â”€ user.model.js
â”œâ”€â”€ routes/
â”‚   â””â”€â”€ post.route.js
```

---

## ğŸ›¡ï¸ `auth.middleware.js` â€“ Protecting Routes

```js
// src/middlewares/auth.middleware.js
import userModel from "../models/user.model.js";
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';

dotenv.config();

const authMiddleware = async (req, res, next) => {
    const token = req.cookies.token;

    if (!token) {
        return res.status(401).json({
            message: "Unauthorized access, please login first"
        });
    }

    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        const user = await userModel.findOne({ _id: decoded.id });

        req.user = user; // Attach the user object to the request
        next(); // Call next() to proceed to the controller
    } catch (error) {
        return res.status(401).json({
            message: "Invalid token, please login again"
        });
    }
};

export { authMiddleware };
```

### ğŸ”„ What It Does:

1. **Checks for JWT token** in the cookie.
2. If not found â†’ returns 401 Unauthorized.
3. If found â†’ verifies it using `jwt.verify`.
4. Looks up the user in the database by decoded tokenâ€™s ID.
5. If valid â†’ attaches the user to `req.user`.
6. Calls `next()` to move on to the controller.

---

## ğŸ“¦ `post.controller.js` â€“ Creating Posts

```js
// src/controllers/post.controller.js
import postModel from "../models/post.model.js";

const createPostController = async(req, res) => {
    const file = req.file;
    console.log(file); // For debugging uploaded image
    // Actual logic to create and save post goes here
};

export default createPostController;
```

### ğŸ“ Notes:

* The controller assumes that a **valid user** is already authenticated and available at `req.user` (set by middleware).
* Handles uploaded image file via `req.file` (handled by Multer).

---

## ğŸ›£ï¸ `post.route.js` â€“ Secured Routes + Multer Upload

```js
// src/routes/post.route.js
import express from 'express';
import { authMiddleware } from '../middlewares/auth.middleware.js';
import createPostController from '../controllers/post.controller.js';
import multer from "multer";

const upload = multer({ storage: multer.memoryStorage() });
const router = express.Router();

router.post('/',
    authMiddleware,              // âœ… Check user is logged in
    upload.single("image"),      // ğŸ“· Handle image file upload
    createPostController         // ğŸ¯ Actual controller
);

export default router;
```

### ğŸ”— Route Flow:

1. `/api/posts` (POST request)
2. â¡ï¸ First passes through `authMiddleware`
3. â¡ï¸ If authenticated, goes to `multer` upload middleware
4. â¡ï¸ Finally reaches `createPostController`

---

## ğŸ¯ Why This Architecture is Ideal

* **Reusability:** `authMiddleware` can be used for any future protected routes.
* **Separation of concerns:** Auth logic is separate from controller logic.
* **Clean structure:** Codebase is organized and easy to maintain.
* **Scalability:** Add more middlewares easily (e.g., role-based access, rate-limiting).

---

## ğŸ”‘ Summary

| Component            | Responsibility                            |
| -------------------- | ----------------------------------------- |
| `auth.middleware.js` | Verifies JWT token & fetches user         |
| `post.controller.js` | Handles business logic (e.g., image post) |
| `post.route.js`      | Connects route to middleware + controller |

---