
# 🔐 Authentication Middleware in Express – Explained

In modern web applications, especially those with **user authentication**, it's common to have certain routes (APIs) that should only be accessible to **logged-in users**. To ensure this, we create a **middleware** that checks the user's authentication before allowing access.

---

## ✅ What Is Middleware?

In Express.js, middleware functions are functions that have access to the **request**, **response**, and the **next** function in the application’s request-response cycle. Middleware can be used to:

* Authenticate users
* Log requests
* Validate data
* Handle file uploads
* And much more

---

## 🧠 Why Create a Separate Authentication Middleware?

When multiple API routes require the **same logic to authenticate a user**, writing this logic in every controller leads to:

* Code duplication
* Maintenance difficulties
* Poor scalability

**Solution:** Create a reusable middleware function that performs the authentication once and can be imported wherever needed.

---

## 📁 Folder Structure Used

```
src/
├── middlewares/
│   └── auth.middleware.js
├── controllers/
│   └── post.controller.js
├── models/
│   └── user.model.js
├── routes/
│   └── post.route.js
```

---

## 🛡️ `auth.middleware.js` – Protecting Routes

```js
// src/middlewares/auth.middleware.js
import userModel from "../models/user.model.js";
import jwt from 'jsonwebtoken';
import dotenv from 'dotenv';

dotenv.config();

const authMiddleware = async (req, res, next) => {
    const token = req.cookies.token;

    if (!token) {
        return res.status(401).json({
            message: "Unauthorized access, please login first"
        });
    }

    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        const user = await userModel.findOne({ _id: decoded.id });

        req.user = user; // Attach the user object to the request
        next(); // Call next() to proceed to the controller
    } catch (error) {
        return res.status(401).json({
            message: "Invalid token, please login again"
        });
    }
};

export { authMiddleware };
```

### 🔄 What It Does:

1. **Checks for JWT token** in the cookie.
2. If not found → returns 401 Unauthorized.
3. If found → verifies it using `jwt.verify`.
4. Looks up the user in the database by decoded token’s ID.
5. If valid → attaches the user to `req.user`.
6. Calls `next()` to move on to the controller.

---

## 📦 `post.controller.js` – Creating Posts

```js
// src/controllers/post.controller.js
import postModel from "../models/post.model.js";

const createPostController = async(req, res) => {
    const file = req.file;
    console.log(file); // For debugging uploaded image
    // Actual logic to create and save post goes here
};

export default createPostController;
```

### 📝 Notes:

* The controller assumes that a **valid user** is already authenticated and available at `req.user` (set by middleware).
* Handles uploaded image file via `req.file` (handled by Multer).

---

## 🛣️ `post.route.js` – Secured Routes + Multer Upload

```js
// src/routes/post.route.js
import express from 'express';
import { authMiddleware } from '../middlewares/auth.middleware.js';
import createPostController from '../controllers/post.controller.js';
import multer from "multer";

const upload = multer({ storage: multer.memoryStorage() });
const router = express.Router();

router.post('/',
    authMiddleware,              // ✅ Check user is logged in
    upload.single("image"),      // 📷 Handle image file upload
    createPostController         // 🎯 Actual controller
);

export default router;
```

### 🔗 Route Flow:

1. `/api/posts` (POST request)
2. ➡️ First passes through `authMiddleware`
3. ➡️ If authenticated, goes to `multer` upload middleware
4. ➡️ Finally reaches `createPostController`

---

## 🎯 Why This Architecture is Ideal

* **Reusability:** `authMiddleware` can be used for any future protected routes.
* **Separation of concerns:** Auth logic is separate from controller logic.
* **Clean structure:** Codebase is organized and easy to maintain.
* **Scalability:** Add more middlewares easily (e.g., role-based access, rate-limiting).

---

## 🔑 Summary

| Component            | Responsibility                            |
| -------------------- | ----------------------------------------- |
| `auth.middleware.js` | Verifies JWT token & fetches user         |
| `post.controller.js` | Handles business logic (e.g., image post) |
| `post.route.js`      | Connects route to middleware + controller |

---