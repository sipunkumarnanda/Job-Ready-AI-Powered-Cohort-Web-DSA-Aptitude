


# ğŸ› ï¸ Update Product API â€“ Detailed Explanation Notes

---

## ğŸ“Œ Complete Code (At One Place)

```js
async function updateProduct(req, res) {
  const { id } = req.params;

  if (!mongoose.Types.ObjectId.isValid(id)) {
    return res.status(400).json({
      message: "Invalid product id",
    });
  }

  try {
    const product = await productModel.findById(id);

    if (!product) {
      return res.status(404).json({
        message: "product not found",
      });
    }

    // Ensure only the product owner (seller) is allowed to update this product
    if (product.seller.toString() !== req.user.id) {
      return res.status(403).json({
        message: "you are not allowed to update this product",
      });
    }

    // Fields that are allowed to be updated
    const allowedUpdates = ["title", "description", "price"];

    // Update only allowed fields from request body
    for (const key of Object.keys(req.body)) {
      if (allowedUpdates.includes(key)) {

        // Special handling for PRICE since it is a nested OBJECT
        // Example: price: { amount: 20, currency: "INR" }
        if (key === "price" && typeof req.body.price === "object") {

          // Update price amount if provided
          if (req.body.price.amount !== undefined) {
            product.price.amount = Number(req.body.price.amount);
          }

          // Update price currency if provided
          if (req.body.price.currency !== undefined) {
            product.price.currency = req.body.price.currency;
          }

        } else {
          // Update simple (non-nested) fields like title or description
          product[key] = req.body[key];
        }
      }
    }

    // Save updated product to database
    await product.save();

    return res.status(200).json({
      message: "product upadted successfully",
      product,
    });
  } catch (error) {
    console.error("Error occured in updateProduct ", error);
    return res.status(500).json({
      message: "Internal server error",
    });
  }
}
```

---

## ğŸ§  Module-Wise Explanation

---

## 1ï¸âƒ£ Async Controller Function ğŸš€

```js
async function updateProduct(req, res)
```

* Express **controller**
* Uses `async/await` for:

  * database queries
  * update operations
* Keeps code readable and manageable

---

## 2ï¸âƒ£ Extracting Product ID from URL ğŸ†”

```js
const { id } = req.params;
```

* Reads product ID from route:

  ```
  PUT /products/:id
  ```

---

## 3ï¸âƒ£ Validating MongoDB ObjectId âœ…

```js
mongoose.Types.ObjectId.isValid(id)
```

### Why this is important:

* Prevents MongoDB cast errors
* Stops unnecessary DB queries
* Improves API stability

ğŸ“Œ Response:

* `400 Bad Request` â†’ invalid ID format

---

## 4ï¸âƒ£ Fetching Product from Database ğŸ—„ï¸

```js
const product = await productModel.findById(id);
```

* Retrieves product document
* Returns `null` if not found

---

## 5ï¸âƒ£ Handling Product Not Found âŒ

```js
if (!product) {
  return res.status(404).json({ message: "product not found" });
}
```

* Handles valid but non-existent product IDs
* Correct HTTP status: **404 Not Found**

---

## 6ï¸âƒ£ Authorization Check (Security) ğŸ”

```js
if (product.seller.toString() !== req.user.id)
```

### Purpose:

* Ensures **only the product owner** can update it
* Prevents unauthorized access

ğŸ“Œ Response:

* `403 Forbidden` â†’ user not allowed

ğŸ§  This is a **critical security step**

---

## 7ï¸âƒ£ Allowed Updates (Field Whitelisting) ğŸ§¾

```js
const allowedUpdates = ["title", "description", "price"];
```

### Why whitelisting?

* Prevents users from updating restricted fields like:

  * `_id`
  * `seller`
  * `createdAt`

ğŸ§  Protects against **mass assignment vulnerabilities**

---

## 8ï¸âƒ£ Iterating Over Request Body Fields ğŸ”

```js
for (const key of Object.keys(req.body))
```

* Dynamically processes only fields sent by the client
* Makes update logic flexible

Example:

```js
req.body = { title: "New Title", price: { amount: 500 } }
```

---

## 9ï¸âƒ£ Checking If Field Is Allowed âœ…

```js
if (allowedUpdates.includes(key))
```

* Only updates safe fields
* Ignores anything else automatically

---

## ğŸ”Ÿ Special Handling for Nested `price` Object ğŸ’°

```js
if (key === "price" && typeof req.body.price === "object")
```

### Why special handling?

* `price` is a **nested object**
* Structure:

```js
price: {
  amount: Number,
  currency: String
}
```

Direct assignment could overwrite data âŒ

---

## 1ï¸âƒ£1ï¸âƒ£ Partial Updates for Nested Fields ğŸ”§

```js
if (req.body.price.amount !== undefined)
```

### Why `!== undefined`?

* Allows valid values like `0`
* Supports partial updates

Example:

```js
{ price: { amount: 300 } }
```

âœ” Currency remains unchanged
âœ” Only amount is updated

---

## 1ï¸âƒ£2ï¸âƒ£ Updating Simple Fields âœï¸

```js
product[key] = req.body[key];
```

* Used for:

  * `title`
  * `description`
* Uses **bracket notation** for dynamic keys

---

## 1ï¸âƒ£3ï¸âƒ£ Saving Updated Product ğŸ—„ï¸

```js
await product.save();
```

* Persists changes
* Runs Mongoose validations & hooks
* Ensures data consistency

---

## 1ï¸âƒ£4ï¸âƒ£ Success Response ğŸ“¤âœ…

```js
return res.status(200).json({
  message: "product upadted successfully",
  product,
});
```

* `200 OK`
* Returns updated product data

---

## 1ï¸âƒ£5ï¸âƒ£ Error Handling ğŸ›‘

```js
catch (error) {
  return res.status(500).json({ message: "Internal server error" });
}
```

* Catches unexpected issues
* Logs error for debugging
* Prevents server crash

---

## ğŸ¯ Interview-Ready Explanation (Impressive)

> â€œI validate the product ID, ensure the product exists, perform an ownership check, whitelist allowed fields, handle nested updates like price separately to allow partial updates, and finally persist changes using Mongooseâ€™s `save()` method.â€

### Bonus Line (Very Impressive):

> â€œThis approach prevents mass assignment vulnerabilities, enforces authorization, and ensures safe, controlled updates.â€

---

## ğŸ§  Key Takeaways (For Revision)

âœ… ObjectId validation
âœ… Authorization & ownership checks
âœ… Field whitelisting
âœ… Safe nested object updates
âœ… Partial updates supported
âœ… Clean async/await usage
âœ… Production-ready controller

---