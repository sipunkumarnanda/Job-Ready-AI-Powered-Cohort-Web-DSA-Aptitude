

# âœ… `userModel.exists()` with Nested Fields (Dot Notation)

in **Mongoose**

---

## ðŸ§± Schema Used in All Examples (IMPORTANT)

Before understanding any query, always look at the **schema structure** ðŸ‘‡

```js
const userSchema = new mongoose.Schema({
  name: String,
  email: String,
  addresses: [
    {
      street: String,
      city: String,
      pincode: String
    }
  ],
  profile: {
    phone: String
  }
});
```

ðŸ“Œ Key points:

* `addresses` â†’ **array of objects**
* Each address has `street`, `city`, `pincode`
* `profile` â†’ nested object (not an array)

ðŸ‘‰ **All examples below are based on this schema**

---

## ðŸ§  What Does This Query Mean?

```js
userModel.exists({
  _id: id,
  "addresses.street": street,
  "addresses.city": city
})
```

### âœ… Meaning (In Simple Words)

This query checks **whether a user exists**:

* With a **specific `_id`**
* AND has **at least ONE address** in `addresses[]`

  * where `street` matches
  * and `city` matches

ðŸ“Œ It does **NOT fetch the document**
ðŸ“Œ It only checks **existence** âœ…

---

## ðŸ” How MongoDB Matches This Query (VERY IMPORTANT ðŸ”¥)

MongoDB uses **dot notation** to query inside arrays of objects.

### Internally, MongoDB checks:

> â€œIs there **at least one object** inside `addresses[]`
> where **street AND city belong to the SAME address object**?â€

âœ” No loops needed
âœ” No full document fetch
âœ” Very fast with indexes ðŸš€

---

## ðŸ” Return Value of `exists()`

| Case        | Return                   |
| ----------- | ------------------------ |
| Match found | `{ _id: ObjectId(...) }` |
| No match    | `null`                   |

ðŸ“Œ Convert to boolean when needed:

```js
const isExists = !!result;
```

---

## ðŸ§ª Example 1: Basic Address Existence Check ðŸ 

```js
const exists = await User.exists({
  _id: userId,
  "addresses.street": "MG Road",
  "addresses.city": "Mumbai"
});

if (exists) {
  console.log("Address already exists");
}
```

---

## ðŸ§ª Example 2: Prevent Duplicate Address Add âž•ðŸš«

```js
const addressExists = await User.exists({
  _id: userId,
  "addresses.street": street,
  "addresses.city": city
});

if (addressExists) {
  return res.status(400).json({
    message: "Address already added"
  });
}
```

ðŸ“Œ **Very common real-world use case**
(Used before `$push` into addresses array)

---

## ðŸ§ª Example 3: Using `$and` (Explicit Form)

```js
User.exists({
  _id: userId,
  $and: [
    { "addresses.street": street },
    { "addresses.city": city }
  ]
});
```

ðŸ“Œ Same result as implicit AND
ðŸ“Œ Useful when logic becomes complex

---

## ðŸ§ª Example 4: Using `$or` with `exists()` ðŸ”€

```js
User.exists({
  _id: userId,
  $or: [
    { "addresses.city": "Delhi" },
    { "addresses.city": "Mumbai" }
  ]
});
```

ðŸ‘‰ Checks if the user has **any address** in Delhi **OR** Mumbai

---

## ðŸš€ Similar `exists()` Patterns You MUST Know

---

### 1ï¸âƒ£ Check Existence in Array (Any Match)

```js
User.exists({
  "addresses.city": "Delhi"
});
```

âœ” Returns true if **any user** has an address in Delhi

---

### 2ï¸âƒ£ Check Multiple Fields in Same Subdocument âœ…

```js
User.exists({
  "addresses.street": "Park Street",
  "addresses.pincode": "700016"
});
```

âœ” Both conditions must match **within the same address object**

---

### 3ï¸âƒ£ Using `$elemMatch` (BEST PRACTICE) ðŸŽ¯ðŸ”¥

```js
User.exists({
  _id: userId,
  addresses: {
    $elemMatch: {
      street: street,
      city: city
    }
  }
});
```

### ðŸ“Œ Why `$elemMatch` is important?

âœ” Ensures matching happens in **one single array element**
âœ” Prevents edge-case mismatches
âœ” Recommended for **interviews & production**

---

### 4ï¸âƒ£ Check Nested Object (Not an Array)

```js
User.exists({
  "profile.phone": "9999999999"
});
```

âœ” Works for nested objects too
âœ” No `$elemMatch` needed

---

## âš–ï¸ Dot Notation vs `$elemMatch`

| Feature        | Dot Notation | `$elemMatch` |
| -------------- | ------------ | ------------ |
| Simple queries | âœ… Good       | âœ… Good       |
| Complex logic  | âš ï¸ Risky     | âœ… Best       |
| Interview safe | âš ï¸           | âœ…            |
| Production use | âš ï¸           | âœ…            |

ðŸ† **Rule:**
ðŸ‘‰ Use `$elemMatch` for **arrays of objects** whenever possible

---

## â° When to Use This Pattern?

âœ… Check if address already exists
âœ… Avoid duplicate subdocuments
âœ… Validation before `$push`
âœ… Ownership / permission checks
âœ… High-performance existence queries

---

## ðŸš« Common Mistakes âŒ

âŒ Expecting boolean directly
âŒ Forgetting `_id` in user-scoped checks
âŒ Not using `$elemMatch` for complex arrays
âŒ Using `find()` instead of `exists()`

---

## ðŸ§  Interview One-Liner ðŸ—£ï¸

> **"`exists()` with dot notation or `$elemMatch` is used to efficiently verify the presence of a matching subdocument without fetching the full document."**

---

## âœ¨ Final Summary

âœ” Schema-first understanding is critical
âœ” `exists()` works perfectly with nested fields
âœ” Dot notation = simple & fast
âœ” `$elemMatch` = safest & recommended
âœ” Returns `_id` or `null`
âœ” Ideal for validation logic ðŸš€

---