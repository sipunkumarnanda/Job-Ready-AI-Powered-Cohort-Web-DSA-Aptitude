

## ğŸ“Œ Code (Kept First â€“ As Requested)

### ğŸ”¹ `redis.js`

```js
const { Redis } = require("ioredis");

const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
});

redis.on("connect", () => {
  console.log("connected to redis");
});

redis.on('error', () => {
  console.error("Redis connection failed : ", error)
})

module.exports = redis;
```

---

### ğŸ”¹ `auth.middleware.js`

```js
const jwt = require('jsonwebtoken')
const redis = require('../db/redis.js')

async function authMiddleware(req, res, next) {
  try {

    const token  = req.cookies?.token
    if(!token){
        return res.status(401).json({
            message : "Unauthorized"
        })
    }

    if (process.env.NODE_ENV !== "test") {
      try {
        const isBlacklisted = await redis.get(`blacklist:${token}`);
        if (isBlacklisted) {
          res.clearCookie("token", {
            httpOnly: true,
            secure: true,
            sameSite: "strict",
          });
          return res.status(401).json({
            message: "Session expired. Please login again.",
          });
        }
      } catch (error) {
        console.error("Redis error in auth middleware ", error);
        return res.status(503).json({
          message: "Authentication service unavailable",
        });
      }
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET)

    const user = decoded
    req.user = user

    next()

  } catch (error) {
     return res.status(401).json({
            message : "Unauthorized user"
        })
  }
}

module.exports = {
    authMiddleware
}
```

---

### ğŸ”¹ `logout.controller.js`

```js
async function logoutUser(req, res) {
  try {
     const token = req.cookies.token
  if(token){
   // blacklist in redis
   await redis.set(`blacklist:${token}`, 'true', 'EX', 24*60*60) // expires in 1 day
  }

  res.clearCookie('token', {
    httpOnly : true,
    secure : true,
    sameSite: "strict"
  })

  return res.status(200).json({
    message : "logged out successfully"
  })
  } catch (error) {
    console.error("Error in logout user ", error)
    return res.status(500).json({
      message : "Internal server error"
    })
  }
}
```

---

# ğŸ“˜ In-Depth Explanation (Module-Wise)

---

## ğŸ”¹ 1. `redis.js` â€” Redis Client Setup

### ğŸ“Œ Purpose

This file:

* Creates a **single Redis client**
* Connects Redis to your application
* Exports Redis for reuse everywhere

---

### â–¶ï¸ Importing Redis

```js
const { Redis } = require("ioredis");
```

* Imports the `Redis` class from `ioredis`
* `ioredis` is production-grade and supports:

  * Auto-reconnect
  * Cluster
  * High availability

---

### â–¶ï¸ Creating Redis Instance

```js
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: process.env.REDIS_PORT,
  password: process.env.REDIS_PASSWORD,
});
```

**What happens here:**

* A live Redis connection is created
* Uses environment variables for security
* Works for local & cloud Redis

ğŸ“Œ **Why env variables?**

* No hard-coded secrets
* Easy deployment across environments

---

### â–¶ï¸ Connection Event

```js
redis.on("connect", () => {
  console.log("connected to redis");
});
```

* Fired when Redis connects successfully
* Useful for monitoring & debugging

---

### â–¶ï¸ Error Event

```js
redis.on('error', () => {
  console.error("Redis connection failed : ", error)
})
```

* Triggered when:

  * Redis is down
  * Credentials are wrong
  * Network fails
* Prevents silent failures

---

### â–¶ï¸ Exporting Redis

```js
module.exports = redis;
```

* Exports **single Redis instance**
* Prevents multiple Redis connections (best practice)

---

## ğŸ”¹ 2. `auth.middleware.js` â€” Authentication Middleware

### ğŸ“Œ Purpose

This middleware:

* Protects private routes
* Validates JWT token
* Uses Redis to **invalidate logged-out tokens**

---

### â–¶ï¸ Imports

```js
const jwt = require('jsonwebtoken')
const redis = require('../db/redis.js')
```

* `jsonwebtoken` â†’ verify JWT
* `redis` â†’ check token blacklist

---

### â–¶ï¸ Reading Token from Cookies

```js
const token  = req.cookies?.token
```

* Extracts JWT from cookies
* Optional chaining avoids crash

---

### â–¶ï¸ No Token â†’ Unauthorized

```js
if(!token){
  return res.status(401).json({
    message : "Unauthorized"
  })
}
```

* If token missing â†’ access denied
* Prevents unauthenticated access

---

### â–¶ï¸ Redis Token Blacklist Check

```js
const isBlacklisted = await redis.get(`blacklist:${token}`);
```

**Why this is important:**

* JWT is stateless (cannot be deleted)
* Redis is used to **blacklist tokens on logout**

ğŸ“Œ Key format:

```txt
blacklist:<JWT_TOKEN>
```

---

### â–¶ï¸ If Token Is Blacklisted

```js
if (isBlacklisted) {
  res.clearCookie("token", {...});
  return res.status(401).json({
    message: "Session expired. Please login again.",
  });
}
```

* Clears cookie
* Blocks access
* Forces re-login

---

### â–¶ï¸ Redis Failure Handling

```js
return res.status(503).json({
  message: "Authentication service unavailable",
});
```

* If Redis is down
* Auth service fails safely
* Prevents insecure access

---

### â–¶ï¸ JWT Verification

```js
const decoded = jwt.verify(token, process.env.JWT_SECRET)
```

* Verifies token signature
* Throws error if invalid or expired

---

### â–¶ï¸ Attaching User to Request

```js
req.user = decoded
```

* Makes user info available to controllers
* Example: `req.user.id`

---

### â–¶ï¸ Calling `next()`

```js
next()
```

* Passes control to protected route

---

## ğŸ”¹ 3. `logout.controller.js` â€” Logout Logic

### ğŸ“Œ Purpose

This controller:

* Logs user out
* Invalidates JWT using Redis
* Clears cookie securely

---

### â–¶ï¸ Reading Token

```js
const token = req.cookies.token
```

* Gets current JWT from cookies

---

### â–¶ï¸ Blacklisting Token in Redis

```js
await redis.set(`blacklist:${token}`, 'true', 'EX', 24*60*60)
```

**What this does:**

* Stores token in Redis blacklist
* TTL = 24 hours
* Auto-expires to save memory

ğŸ“Œ This matches JWT expiry â†’ best practice

---

### â–¶ï¸ Clearing Cookie

```js
res.clearCookie('token', {
  httpOnly : true,
  secure : true,
  sameSite: "strict"
})
```

* Removes JWT from browser
* Prevents XSS & CSRF attacks

---

### â–¶ï¸ Success Response

```js
return res.status(200).json({
  message : "logged out successfully"
})
```

* Confirms logout

---

## ğŸ”„ Overall Flow (Very Important)

```
Login â†’ JWT issued â†’ Stored in cookie
   â†“
Auth Middleware:
  â”œâ”€ Check token
  â”œâ”€ Check Redis blacklist
  â”œâ”€ Verify JWT
   â†“
Protected route access
   â†“
Logout:
  â”œâ”€ Token added to Redis blacklist
  â”œâ”€ Cookie cleared
```

---

## ğŸ§  Why Redis Is Used Here (Key Insight)

JWT alone âŒ cannot be invalidated
Redis âœ… allows **logout & session invalidation**

ğŸ‘‰ This makes JWT authentication **stateful when needed**

---

## ğŸ¯ Interview-Ready Explanation (Short)

> **Redis is used here to blacklist JWT tokens on logout, enabling secure session invalidation in a stateless JWT authentication system.**

---

## ğŸ Final Summary ğŸŒŸ

âœ”ï¸ Redis used as **JWT blacklist store**
âœ”ï¸ Secure logout implementation
âœ”ï¸ Production-ready auth middleware
âœ”ï¸ Solves JWT logout limitation
âœ”ï¸ Clean, scalable architecture

---