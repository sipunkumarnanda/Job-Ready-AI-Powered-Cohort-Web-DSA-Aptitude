

# 3ï¸âƒ£ Pagination

Pagination means:

> â€œDonâ€™t send all posts at once â€” send them in chunks (pages).â€

Two main strategies:

1. **Page-based (skip/limit)** â†’ easy, but slow for large pages
2. **Cursor-based (keyset)** â†’ fast, scalable, required for infinite scroll

---

# A) ğŸ“„ Page-based pagination (`skip()` + `limit()`)

### Code

```js
Post.find()
  .sort({ createdAt: -1 })
  .skip((page - 1) * pageSize)
  .limit(pageSize);
```

---

# ğŸ” What each line does

### 1. `.find()`

Fetch posts.

### 2. `.sort({ createdAt: -1 })`

Sort by newest posts first.

Meaning:

* First page = newest posts
* Next pages = older posts

### 3. `.skip((page - 1) * pageSize)`

Skip N documents before reading anything.

Example:
If `page = 3` and `pageSize = 10`:

```
skip(20)
```

Meaning:

* Hold first 20 rows in DB
* Throw them away
* Start returning from row 21

### 4. `.limit(pageSize)`

Return only `pageSize` documents (e.g., 10).

---

# âœ”ï¸ Good things

* Very easy to implement
* Perfect for normal websites with page 1 â†’ 2 â†’ 3 navigation

# âš ï¸ Bad things (big issue)

`skip()` gets slow as page grows.

Example:

```
page = 10000
skip = 9999 * 10 = 99,990 rows
```

MongoDB must walk over ~100k rows and throw them away â†’ **slow**.

Great for page 1-50,
Terrible for page 10,000.

---

# B) ğŸš€ Cursor-based pagination (Keyset pagination)

### Code

```js
Post.find({
  createdAt: { $lt: lastSeen }
})
.sort({ createdAt: -1 })
.limit(10);
```

---

# ğŸ” What each line does

### 1. `.find({ createdAt: { $lt: lastSeen } })`

**Filter posts where:**

```
createdAt < lastSeen
```

Meaning:
â€œGive me posts that are **older** than the last post the user saw.â€

This avoids skipping entirely.

---

### Example visual



## Assume posts sorted by createdAt (newest first):

```
p1 (createdAt = 100)
p2 (createdAt = 90)
p3 (createdAt = 80)
p4 (createdAt = 70)
p5 (createdAt = 60)
```

(We just use numbers to make it easy.)

When user loads **page 1**, they get:

```
[p1, p2, p3]
```

The **lastSeen** timestamp becomes:

```
lastSeen = p3.createdAt = 80
```

---

# ğŸ” Now second request uses:

```js
createdAt: { $lt: lastSeen }
```

Which means:

```
createdAt < 80
```

---

# ğŸ“Œ How â€œless thanâ€ ($lt) works here

MongoDB is simply checking:

> Return all posts whose `createdAt` value is **older** (less) than 80.

Look at our timestamps:

* p1 â†’ 100 âŒ (greater than 80 â†’ too new)
* p2 â†’ 90 âŒ (too new)
* p3 â†’ 80 âŒ (equal â†’ skip)
* p4 â†’ 70 âœ”ï¸ (older â†’ match)
* p5 â†’ 60 âœ”ï¸ (older â†’ match)

So matching posts are:

```
p4, p5
```

Then `.sort({ createdAt: -1 })` orders them newest â†’ oldest:

```
p4 (70)
p5 (60)
```

---

# ğŸ§© Why â€œless thanâ€ means â€œolder postâ€?

Because in timestamps:

* **Higher number** = newer time
* **Lower number** = older time

So:

```
70 < 80  â†’ 70 happened before 80 â†’ p4 is older than p3
60 < 80  â†’ p5 is even older
```

---

# ğŸŒŠ Visual Timeline

```
Newer â†’ â†’ â†’ â†’ Older

100   90   80   70   60
 p1   p2   p3   p4   p5
           â†‘
       lastSeen = 80

Next page condition:
createdAt < 80 â†’ fetch to the RIGHT
```

Cursor pagination **moves to the right** on the timeline (towards older posts).

---

# ğŸ”¥ Why this works perfectly

Because we are literally saying:

> â€œGive me posts OLDER than the last one I saw.â€

There is **no skipping**, no wasted work.

---

# ğŸ§  More intuitive explanation

Imagine posts are sorted by date:

```
Jan 10 newest
Jan 5
Jan 2
Dec 28
Dec 20 oldest
```

If the last post the user saw was **Jan 2**,
the next set should be:

```
Dec 28, Dec 20
```

These satisfy:

```
post.createdAt < "Jan 2"
```

---

# âœ”ï¸ Summary

The `<` operator simply filters older posts:

* First page: newest posts
* Store lastSeen = last post timestamp
* Next page: get posts *older* than lastSeen

---

### 2. `.sort({ createdAt: -1 })`

Still sort newest first.

This ensures continuity:

* Page 1: newest X posts
* Page 2: posts **older** than lastSeen
* Page 3: older than that, and so on

---

### 3. `.limit(10)`

Give only the next 10 posts.

---

# âœ”ï¸ Good things (why itâ€™s best)

### âœ”ï¸ **Super fast** even for millions of documents

MongoDB just uses an index:

```
createdAt < value â†’ jump directly to next chunk
```

### âœ”ï¸ Perfect for infinite scroll (Instagram, TikTok, Reddit)

### âœ”ï¸ Smooth user experience

No missing/duplicated items.

---

# âŒ Downside

You must remember the **cursor**.

Cursor usually =

* `lastSeenCreatedAt` (timestamp)
* or `{ createdAt, _id }` pair (if you need stable ordering)

Client sends cursor on every next-page request.

---

# ğŸ§  Summary of what the code is doing:

## Page-based pagination

```
skip â†’ throw away rows
limit â†’ take N rows
```

Good for page buttons
Bad for deep pages

---

## Cursor-based pagination

```
find posts older than lastSeen
sort newestâ†’oldest
limit N rows
```

Good for infinite scroll
Fast even at deep pages
No skip â†’ highly efficient

---