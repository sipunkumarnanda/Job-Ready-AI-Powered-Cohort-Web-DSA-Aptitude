

# ğŸ§© **Mongoose Getters & Setters â€” Complete In-Depth Notes (Beginner â†’ Advanced)**

âœ¨ *Clean. Visual. Explained line-by-line. All-in-one master note.*

---

# ğŸ“˜ **1. What Are Getters & Setters in Mongoose?**

## âœ¨ Simple Definition

**Getters** â†’ run when data is *read* from a document
**Setters** â†’ run when data is *written* or *modified* before saving

### âœ” Both getters and setters:

* âŒ Do NOT store extra fields in MongoDB
* âš™ï¸ Are applied inside the schema
* ğŸ¤ Work like â€œdata filtersâ€
* ğŸ” Help keep data clean, formatted, consistent

---

# ğŸ’¡ **2. Why Do We Use Getters & Setters?**

### âœ” 1. Automatically format data

Example: always lowercase emails
Example: trim whitespace from names

### âœ” 2. Enforce clean data before saving

Example: capitalize the first letter
Example: convert string numbers to integers

### âœ” 3. Transform data when reading

Example: format dates
Example: convert stored USD â†’ INR on read

### âœ” 4. Hide/modify sensitive values

Example: mask phone numbers
Example: round off prices

### âœ” 5. Avoid repeating formatting code

More consistent outputs.

---

# ğŸ§  **3. Important: Getters/Setters Are Part of the Schema**

Just like virtuals, **they apply on the Schema**, not the Model.

Why?

* Schema defines how fields behave
* Model simply uses the schema
* Documents inherit these behaviors

---

# ğŸ”§ **4. Basic Syntax for Getters & Setters**

```js
UserSchema.path("email").get(fn); // getter
UserSchema.path("email").set(fn); // setter
```

Where:

* `.get()` â†’ runs when reading the field
* `.set()` â†’ runs when writing/modifying the field

---

# ğŸ”¥ **5. Getter Example â€” Always Lowercase Email**

```js
const UserSchema = new mongoose.Schema({
  email: String
});

UserSchema.path("email").get(function (value) {
  return value ? value.toLowerCase() : value;
});
```

---

# ğŸ§µ **Line-by-Line Explanation**

### 1ï¸âƒ£

```js
const UserSchema = new mongoose.Schema({
  email: String
});
```

* Creating schema for user
* Email stored as string in MongoDB

---

### 2ï¸âƒ£

```js
UserSchema.path("email")
```

* We select the **email** field inside the schema
* `path()` gives access to modify its behavior

---

### 3ï¸âƒ£

```js
.get(function (value) {
```

* `.get()` defines a **getter**
* Runs whenever somebody reads `user.email`
* `value` is whatâ€™s stored in MongoDB

---

### 4ï¸âƒ£

```js
return value ? value.toLowerCase() : value;
```

* Ensures all emails returned are lowercase
* Even if stored as uppercase in DB

---

# ğŸ§ª Example: Using Getter

```js
const User = mongoose.model("User", UserSchema);

const user = await User.findById("u1");

console.log(user.email);  // always lowercase
```

---

# ğŸ”¥ **6. Setter Example â€” Trim Whitespace**

```js
UserSchema.path("name").set(function (value) {
  return value.trim();
});
```

---

# ğŸ§µ **Line-by-Line Explanation**

### 1ï¸âƒ£

```js
UserSchema.path("name")
```

* Accesses the schema field `name`

---

### 2ï¸âƒ£

```js
.set(function (value) {
```

* `.set()` means:

  > "Run this whenever someone **sets** or **changes** name"

---

### 3ï¸âƒ£

```js
return value.trim();
```

* Trims whitespace before saving
* Ensures DB never stores `"  Alex  "` â†’ always `"Alex"`

---

# ğŸ§ª Usage Example

```js
const user = new User({ name: "   Alex   " });
await user.save();

console.log(user.name); 
// â†’ "Alex"
```

---

# ğŸŒŸ **7. Combining Getter + Setter on Same Field**

```js
UserSchema.path("username")
  .set(v => v.trim().toLowerCase())   // clean before saving
  .get(v => "@" + v);                 // add @ when reading
```

### Output:

* Stored in DB â†’ `"alex"`
* Returned when reading â†’ `"@alex"`

---

# ğŸ“¤ **8. Getters/Setters in JSON Output**

By default:

* JSON responses (`res.json`) DO apply getters
* But only if you enable them:

```js
UserSchema.set("toJSON", { getters: true });
UserSchema.set("toObject", { getters: true });
```

---

# ğŸ§µ **Line-by-Line Explanation**

### 1ï¸âƒ£

```js
UserSchema.set("toJSON", { getters: true });
```

* When converting Document â†’ JSON
* Apply getters to field values

### 2ï¸âƒ£

```js
UserSchema.set("toObject", { getters: true });
```

* Same for converting to plain JS objects

Without this:

* API response may show raw values (untransformed)

---

# ğŸ§© **9. Full Working Example (Clean & Complete)**

```js
const UserSchema = new mongoose.Schema({
  email: String,
  name: String
});

// Getter
UserSchema.path("email").get(function (v) {
  return v?.toLowerCase();
});

// Setter
UserSchema.path("name").set(function (v) {
  return v.trim();
});

// Enable in JSON
UserSchema.set("toJSON", { getters: true });
UserSchema.set("toObject", { getters: true });

const User = mongoose.model("User", UserSchema);

// Use
const user = await User.findById("u1");
console.log(user.email);
console.log(user.name);
```

---

# ğŸŒˆ **10. More Advanced Real-Life Examples**

## â­ 1. Format Date Automatically

```js
UserSchema.path("createdAt").get(function (v) {
  return v.toLocaleDateString();
});
```

---

## â­ 2. Round Off Prices

```js
ProductSchema.path("price").get(v => Math.round(v));
```

---

## â­ 3. Hash Password Using Setter

```js
UserSchema.path("password").set(function (value) {
  return bcrypt.hashSync(value, 10);
});
```

---

## â­ 4. Convert String to Number

```js
OrderSchema.path("quantity").set(v => parseInt(v, 10));
```

---

# âš¡ **11. Important Gotchas / Limitations**

### â— 1. Getters & Setters DO NOT work with `.lean()`

```js
await User.find().lean();
```

Why?

* `.lean()` returns plain objects
* Mongoose does not apply schema logic

âœ” Workaround:

```js
User.find().lean({ getters: true })
```

*(depends on Mongoose version)*

---

### â— 2. They do NOT modify database structure

* They only transform values on read/write

---

### â— 3. They run per-property

* They do NOT run on nested fields unless defined individually

---

### â— 4. Too many getters can affect performance

* Because they run every time the field is accessed

---

# ğŸ§¾ **12. Getters & Setters vs Virtuals (Comparison Table)**

| Feature                    | Getters/Setters     | Virtuals                 |
| -------------------------- | ------------------- | ------------------------ |
| Stored in DB?              | âŒ No                | âŒ No                     |
| Modify data before saving? | âœ” Setters           | âŒ No                     |
| Modify data when reading?  | âœ” Getters           | âœ” Virtuals               |
| Based on other fields?     | Sometimes           | Always                   |
| Need enabling for JSON?    | Yes                 | Yes                      |
| Work with `.lean()`?       | âŒ No (default)      | âŒ No (default)           |
| Use case                   | formatting/cleaning | combining/derived fields |

---

# ğŸ“„ **13. Mini Cheat Sheet (Exam Style)**

```
Getter â†’ runs on read
Setter â†’ runs on write
Defined on Schema â†’ not Model
Enable with:
  Schema.set('toJSON', { getters: true })
  Schema.set('toObject', { getters: true })
Do NOT work with .lean()
Useful for:
  - lowercase email
  - trim names
  - format dates
  - mask sensitive data
  - hash passwords
```

---

# ğŸ **14. Final Summary (Easy to Remember)**

### âœ” Getters modify how data is READ

### âœ” Setters modify how data is WRITTEN

### âœ” Both apply on Schema

### âœ” Not stored in DB

### âœ” Must enable for JSON

### âœ” Donâ€™t work with `.lean()` by default

### âœ” Best used for formatting, sanitizing, and transforming fields

---