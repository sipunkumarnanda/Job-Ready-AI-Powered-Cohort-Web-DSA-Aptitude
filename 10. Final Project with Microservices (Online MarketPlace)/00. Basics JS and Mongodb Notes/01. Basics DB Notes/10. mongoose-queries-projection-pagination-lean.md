

# ðŸ”Ž Projection (`select`) â€” include / exclude fields (deep)

**Why:** reduce network payload and avoid leaking sensitive fields.

---

## Example 1 â€” Basic include fields

### Schema (context)

```js
const UserSchema = new mongoose.Schema({
  name: String,
  email: String,
  age: Number,
  password: { type: String, select: false } // default hidden
});
const User = mongoose.model('User', UserSchema);
```

### DB document (stored)

```json
{
  "_id": "u1",
  "name": "Alex",
  "email": "alex@mail.com",
  "age": 30,
  "password": "$2b$10$hash"
}
```

### Query + output

```js
const result = await User.findById('u1').select('name email');
```

**Output**

```json
{ "_id":"u1", "name":"Alex", "email":"alex@mail.com" }
```

### Line-by-line explanation

1. `User.findById('u1')`

   * Build a query to fetch the document with `_id === 'u1'`.
2. `.select('name email')`

   * Projection: include only `name` and `email`. `_id` is included by default.
3. `await` executes the query and returns the document with only selected fields.

**Notes:** `password` was hidden by schema (`select: false`) â€” not shown.

---

## Example 2 â€” Exclude fields

### Query

```js
const result = await User.findById('u1').select('-age -_id');
```

**Output**

```json
{ "name":"Alex", "email":"alex@mail.com" }
```

### Explanation

1. `.select('-age -_id')`

   * `-age` excludes `age`
   * `-_id` excludes `_id` (explicit allowed).
   * You cannot mix inclusion and exclusion in same select (except `_id`).

---

## Example 3 â€” Include a `select:false` field temporarily

### Query

```js
const result = await User.findById('u1').select('+password name');
```

**Output**

```json
{ "_id":"u1", "name":"Alex", "password":"$2b$10$hash" }
```

### Explanation

1. `+password` overrides the schema-level `select: false` for this query. Use carefully (donâ€™t return to clients).

---

## Important gotchas (short)

* Donâ€™t mix includes and excludes (e.g., `.select('name -email')`) â€” invalid.
* Use `.select('+privateField')` only in server-internal code.
* Projection happens on the DB side â€” efficient.

---

# ðŸ”¢ Sorting (`sort()`) â€” in depth

**Why:** control result order; use indexes for heavy sorts.

---

## Example â€” sort by createdAt descending then title ascending

### Schema snippet

```js
const PostSchema = new mongoose.Schema({
  title: String,
  createdAt: { type: Date, default: Date.now }
});
const Post = mongoose.model('Post', PostSchema);
```

### Query

```js
const posts = await Post.find()
  .sort({ createdAt: -1, title: 1 })
  .select('title createdAt')
  .limit(20)
  .lean();
```

### Line-by-line

1. `Post.find()` â€” create a query for all posts.
2. `.sort({ createdAt: -1, title: 1 })`

   * Sort primarily by `createdAt` descending (newest first).
   * Break ties by `title` ascending.
3. `.select('title createdAt')` â€” return only those fields.
4. `.limit(20)` â€” only top 20 results.
5. `.lean()` â€” return POJOs for speed.
6. `await` executes and returns the sorted array.

### Notes

* If you sort by `createdAt`, put an index on `createdAt` for large collections.
* Compound indexes can support sort + filter combos (e.g., `{ user: 1, createdAt: -1 }`).

---

# ðŸ”¢ Pagination â€” `limit()` and `skip()` and keyset (cursor) pagination

---

## A) Page-based (skip+limit) â€” simple

```js
const pageSize = 10;
const page = 3;
const posts = await Post.find({ published: true })
  .sort({ createdAt: -1 })
  .skip((page - 1) * pageSize)
  .limit(pageSize)
  .lean();
```

### Explanation

* `.skip((page-1)*pageSize)` discards first N documents.
* `.limit(pageSize)` returns at most pageSize docs.
* Works for small page numbers.

### Pitfall

* `skip()` becomes slow for deep pages (database must scan discarded docs).

---

## B) Keyset (cursor-based) â€” recommended for deep paging

**Concept:** ask for documents *before* or *after* a cursor value instead of skipping.

```js
// client sends lastSeenCreatedAt (ISO string)
const posts = await Post.find({ published: true, createdAt: { $lt: new Date(lastSeenCreatedAt) } })
  .sort({ createdAt: -1 })
  .limit(10)
  .lean();
```

### Explanation

* Uses `createdAt < lastSeen` to fetch next page.
* Avoids skip cost and performs well with large offsets.
* Use a unique tie-breaker if createdAt is not unique (e.g., `_id`).

---

# ðŸ§© Document vs Plain JS Object â€” deep, with examples

This is the center of understanding `.lean()`.

---

## A) What a Mongoose Document gives you â€” example & line-by-line

### Code

```js
const userDoc = await User.findById('u1'); // no .lean()
userDoc.name = 'Bob';
console.log(typeof userDoc.save);   // "function"
console.log(userDoc.isModified('name')); // true
await userDoc.save();
```

### DB before (stored)

```json
{ "_id":"u1", "name":"Alex", "email":"alex@mail.com" }
```

### What happens

1. `User.findById('u1')`

   * Mongoose runs the query and **hydrates** the raw DB object into a Mongoose Document (instance of model).
   * The object includes schema behavior, methods, and change tracking.
2. `userDoc.name = 'Bob'` â€” modifies the document in memory.
3. `userDoc.isModified('name')` â†’ true: Mongoose tracked the change.
4. `userDoc.save()` â†’ Mongoose will run validators, pre-save hooks, then persist the change.

**Why useful**

* When you need to update the document using instance logic (pre-save middleware, validation), Documents are needed.

---

## B) What a POJO (plain object) looks like â€” example & line-by-line

### Code

```js
const userObj = await User.findById('u1').lean();
console.log(userObj.save); // undefined
userObj.name = 'Bob';      // just modify in-memory
// cannot save; to persist, use Model.updateOne(...) or re-fetch as Document
```

### Output (POJO)

```json
{ "_id":"u1", "name":"Alex", "email":"alex@mail.com" }
```

### Explanation

1. `.lean()` tells Mongoose: return raw result as plain object â€” no hydration.
2. No `.save()` method exists â€” itâ€™s not an instance of model.
3. To persist changes, call `User.findByIdAndUpdate('u1', { $set: { name: 'Bob' } })` or re-query as Document.

**When to use POJO**

* Read-only endpoints (API GET) â€” faster and lighter.
* Bulk queries where you wonâ€™t modify documents.

---

## C) Mixed example showing why not to call `.save()` on lean result

**Wrong:**

```js
const user = await User.findOne({ email: 'a@mail.com' }).lean();
user.age = 31;
await user.save(); // âŒ error: save is not a function
```

**Correct patterns:**

1. Use update:

```js
await User.updateOne({ email: 'a@mail.com' }, { $set: { age: 31 } });
```

2. Or rehydrate:

```js
const userDoc = await User.findOne({ email: 'a@mail.com' });
userDoc.age = 31;
await userDoc.save();
```

---

# âœ¨ Virtuals â€” computed fields not stored in DB (in depth)

**Why:** compute commonly used derived values without storing them.

---

## Example â€” `fullName` virtual

### Schema

```js
const UserSchema = new mongoose.Schema({
  firstName: String,
  lastName: String,
  password: { type: String, select: false }
});

// define virtual
UserSchema.virtual('fullName').get(function() {
  return `${this.firstName} ${this.lastName}`;
});

// include virtuals when converting
UserSchema.set('toObject', { virtuals: true });
UserSchema.set('toJSON', { virtuals: true });

const User = mongoose.model('User', UserSchema);
```

### DB document

```json
{ "_id":"u1", "firstName":"Alex", "lastName":"Johnson", "password":"$2b$hash" }
```

### Using Document

```js
const userDoc = await User.findById('u1');
console.log(userDoc.fullName); // "Alex Johnson"
res.json(userDoc); // JSON includes fullName and excludes password if transform hides it
```

### Line-by-line (virtual)

1. `UserSchema.virtual('fullName')` â€” declares a virtual field named `fullName`.
2. `.get(function() { ... })` â€” defines how to compute it; `this` is a document.
3. `set('toObject', { virtuals: true })` â€” when converting document to plain object, include virtuals.

---

## Virtuals + `.lean()` â€” default behavior & plugin

* **Default:** `.lean()` **does not** include virtuals.
* If you need virtuals with lean results, options:

  * Use a plugin like `mongoose-lean-virtuals`.
  * Manually compute values after `.lean()` (map over results and compute).
  * Rehydrate as Document (but that negates lean performance).

### Example computing manually

```js
const users = await User.find().select('firstName lastName').lean();
const withFull = users.map(u => ({ ...u, fullName: `${u.firstName} ${u.lastName}` }));
```

### Plugin-based (concept)

```js
// plugin setup (example, plugin API may vary)
UserSchema.plugin(require('mongoose-lean-virtuals'));

// query
const users = await User.find().lean({ virtuals: true });
console.log(users[0].fullName); // available
```

---

# ðŸ§° Getters, Setters, and Transforms â€” how they interact with Documents and lean()

---

## Getters example (lowercase email)

### Schema getter

```js
UserSchema.path('email').get(function(v) {
  return v ? v.toLowerCase() : v;
});
```

### Document behavior

```js
const userDoc = await User.findById('u1');
console.log(userDoc.email); // "alex@mail.com" (getter applied)
```

### lean() behavior

* By default, `.lean()` bypasses schema getters.
* You can request getters in lean with options in some Mongoose versions: `.lean({ getters: true })` or using plugins. (Test your Mongoose version.)

---

## toJSON / toObject transforms example (hide password, add id)

### Schema transform

```js
UserSchema.set('toJSON', {
  transform(doc, ret) {
    delete ret.password;     // remove password
    ret.id = ret._id;        // add id alias
    delete ret._id;          // remove _id
    return ret;
  },
  virtuals: true
});
```

### Document output

```js
const userDoc = await User.findById('u1');
res.json(userDoc); // { id: "u1", firstName:"Alex", lastName:"Johnson", fullName:"Alex Johnson" }
```

### lean() output

* `.lean()` bypasses toJSON transform, so `password` won't be removed by transform â€” **you must remove sensitive fields manually or use `select`**.

**Therefore**: always use `.select('-password')` or strip fields when returning lean results.

---

# âœ… Best practices & patterns (practical)

1. **GET endpoints (list/details):** use `.lean()` + `.select(...)` + `.populate(...).lean()` to minimize payload and memory. Always `.select()` to avoid leaking passwords.

   ```js
   const posts = await Post.find({ published: true })
     .select('title excerpt author')
     .populate('author', 'name avatarUrl')
     .sort({ createdAt: -1 })
     .limit(20)
     .lean();
   ```

   * Line-by-line: find posts, pick fields, populate author with only name/avatar, sort newest, limit 20, return POJOs.

2. **Update flows:** donâ€™t use `.lean()` if you plan to mutate and call `.save()`. Use `findById()` without `.lean()` or use atomic updates (`findByIdAndUpdate`).

3. **Virtuals with lean:** either compute manually or use `mongoose-lean-virtuals` plugin.

4. **Pagination:** prefer keyset (cursor) pagination for deep pages; use skip only for shallow pages.

5. **Hiding sensitive fields:** rely on `.select('-password')` or `select:false` in schema and explicitly include fields only as needed. For lean results, explicitly exclude sensitive fields.

6. **Testing & Profiling:** benchmark with real data; measure memory usage and latency to decide whether lean is worth it.

---

# ðŸ§¾ Quick cheat-sheet to paste in your notebook

```
-- Projection --
.select('a b') -> include a,b (+ _id)
.select('-a -_id') -> exclude a and _id

-- Sorting --
.sort({ createdAt: -1 }) -> newest first
.sort({ user:1, createdAt:-1 }) -> compound

-- Pagination --
.skip(n).limit(m) -> page-based (slow for large n)
Cursor (keyset): { createdAt: { $lt: last } } + sort + limit -> fast

-- Document vs POJO --
Document: .save(), validators, virtuals, getters, transforms
POJO (lean): plain fields only, faster, no .save()

-- Virtuals --
Schema.virtual('fullName').get(...)
Set virtuals in toObject/toJSON with { virtuals: true }
Lean doesn't include virtuals by default (use plugin or compute manually)

-- Getters/Transforms --
Applied to Documents/toObject()/toJSON()
Lean bypasses them unless using options/plugins; manually handle security for lean outputs
```

---